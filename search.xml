<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node.js 基础]]></title>
    <url>%2F2019%2F10%2F05%2FNode.js%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[node.js 的 基础。 node.js 基础 node.js 文档（英文） node.js 文档（中文） 全局变量有包括 console（输出），__dirname（文件目录位置），__filename（文件位置） 等全局对象，具体可看官方文档。 全局变量文档（中文） 模块node.js 的导入导出与 JavaScript 不同，导出使用 module.exports，导入使用 require() 单个 导出/导入 导出 1234let count = (arr) =&gt; &#123; return `$&#123;arr.length&#125; elements in the array`&#125;module.exports = count 导入 123var counter = require('./count')console.log(counter(['ruby','vue','react'])) 多个 导出/导入 导出 12345678910111213let count = (arr) =&gt; &#123; return `$&#123;arr.length&#125; elements in the array`&#125;let adder = (a,b) =&gt; &#123; return `the sum fo the two number is $&#123;a+b&#125;`&#125;let pi = 3.14module.exports.counter = countmodule.exports.adder = addermodule.exports.pi = pi 上面的写法相当于暴露了一个对象，等同于： 123456789101112131415let count = (arr) =&gt; &#123; return `$&#123;arr.length&#125; elements in the array`&#125;let adder = (a,b) =&gt; &#123; return `the sum fo the two number is $&#123;a+b&#125;`&#125;let pi = 3.14module.exports = &#123; counter:count, adder, pi&#125; 导入 12345var stuff = require('./count')console.log(stuff.counter(['ruby','vue','react']))console.log(stuff.adder(2,6))console.log(stuff.pi) 这里就是接收了一个对象，然后调用里面的方法，等同于： 1234567var counter = require('./count').countervar adder = require('./count').addervar pi = require('./count').piconsole.log(counter(['ruby','vue','react']))console.log(adder(2,6))console.log(pi) 事件基础node.js 写事件的方法： 12345678910111213// 导入事件库let events = require('events');// 新增事件let myEmitter = new events.EventEmitter();// 绑定监听函数myEmitter.on('someEvent',(message)=&gt;&#123; console.log(message);&#125;)// 触发事件（代码触发）myEmitter.emit('someEvent','the event was emitted'); 首先导入事件库，然后新增事件，之后绑定监听函数，这里和 JavaScript 一样，都是一个事件名称加一个回调函数。 触发事件的时候我们用代码触发，直接加上事件的名称，会自动去找事件然后触发。 进阶1234567891011121314151617181920212223242526272829// 导入事件库let events = require('events');// 导入工具库let util = require('util')// 定义一个父类let Person = function (name) &#123; this.name = name&#125;// inherits 表示继承，可查阅官方文档util.inherits(Person, events.EventEmitter);let make = new Person('make');let lily = new Person('lily');let july = new Person('july');let person = [make, lily, july]// 循环数组绑定事件person.forEach(function(person)&#123; person.on('speak',function(message)&#123; console.log(person.name + ` said:` + message); &#125;)&#125;)make.emit('speak','hi')lily.emit('speak','how are you')july.emit('speak','nice to meet you') events 事件触发器库文档（中文） util 工具库文档（中文） 文件系统（同步、异步）读取文件内容 同步 简单读取同目录下的文件 ReacMe.txt： 1234567// 导入文件系统库let fs = require('fs');// 读取文件（第一个参数是文件目录，第二个参数是编码格式)let readMe = fs.readFileSync('readMe.txt','utf8');console.log(readMe) 现在就可以打印出当前的文件内容了。 异步 123let readme = fs.readFile('readMe.txt','utf8',function(err,data)&#123; console.log(data)&#125;) fs.readFile 是异步的，它的第一个参数是文件目录，第二个参数是一个回调函数： 1234fs.readFile('&lt;目录&gt;', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); node.js 有一个事件队列，执行当异步操作时，会去事件队列中注册一个事件，这时主线程不会立即执行它，而是分配一个线程去执行它，主线程继续执行其他的同步操作，当分线程执行完毕后，会在主线程空闲时把执行结果反馈给主线程，主线程在来执行异步操作的回调函数。 写入文件内容 同步 123456let fs = require('fs');let readMe = fs.readFileSync('readMe.txt','utf8');// 第一个参数是要写入的文件名，第二个文件是要写入的内容fs.writeFileSync('wirteMe.txt',readMe) 执行完毕后，会在当前目录下创建一个文件：writeMe.txt（因为当前没有这个文件，有就不会创建），并写入 readMe 这个变量的内容。 异步 123fs.writeFile('writeMe.txt',readMe,function(err,data)&#123; console.log('write is finished') &#125;) 文件系统文档（中文） 删除文件 同步 1fs.unlinkSync('readMe.txt') 异步 1234fs.unlink('writeMe.txt', (err) =&gt; &#123; if (err) throw err; console.log('文件已删除');&#125;); 综合创建一个目录，并且把当前目录下的一个文件复制到新创建的目录中去： 123456789let fs = require('fs');fs.mkdir('stuff',function()&#123; fs.readFile('readMe.txt','utf8',function(err,data)&#123; fs.writeFile('./stuff/readMe.txt',data,function(err,data)&#123; console.log('success!') &#125;) &#125;)&#125;) 流和管道在 node.js 中，数据的请求和响应对应的就是输入和输出的流，webpack，gulp 等也大量运用了流，文件的打包压缩也是通过流来实现的。 读取数据的流1234567891011121314151617181920let fs = require('fs')// 创建一个输入的流，读取 readMe.txtlet myReadStream = fs.createReadStream(__dirname + '/readMe.txt')// 如果没有加入编码而是直接输出，输出的是 BuffermyReadStream.setEncoding('utf8')let data = ''// data =&gt; 接收数据用的监听函数myReadStream.on('data',function(chunk)&#123; console.log(chunk) // 如果没有加入编码，这里会输出 buffer data += chunk;&#125;)// end =&gt; 结束之后的监听函数myReadStream.on('end',function()&#123; console.log(data)&#125;) 以上就实现了一个简单的读取 readMe.txt 中数据的流，它就相当于上面的文件系统中的读取文件内容。 写入数据的流12345678910111213141516171819202122let fs = require('fs')// 创建一个输入的流，读取 readMe.txtlet myReadStream = fs.createReadStream(__dirname + '/readMe.txt');// 创建一个输出的流，修改 writeMe.txtlet myWriteStream = fs.createWriteStream(__dirname + '/writeMe.txt');// 如果没有加入编码而是直接输出，输出的是 BuffermyReadStream.setEncoding('utf8')let data = ''// data =&gt; 接收数据用的监听函数myReadStream.on('data',function(chunk)&#123; // 写入数据 myWriteStream.write(chunk)&#125;)// end =&gt; 结束之后的监听函数myReadStream.on('end',function()&#123; // console.log(data)&#125;) 上面的代码在读取的基础上做了一些修改，我们创建了一个输出了流，在读取了 readMe.txt 后，把 readMe.txt 的内容给了 writeMe.txt，它就相当于上面的文件系统中的写入文件内容。 再来试一遍写入的流： 1234567891011121314let fs = require('fs')// 创建一个输出的流，修改 writeMe.txtlet myWriteStream = fs.createWriteStream(__dirname + '/writeMe.txt');// 创建一个数据let writeData = 'hello word';// write =&gt; 写入，第一个参数是数据，第二个参数是编码myWriteStream.write(writeData,'utf8');// end =&gt; 写入结束myWriteStream.end()// finish =&gt; 结束后的监听函数myWriteStream.on('finish',function()&#123; console.log('finish')&#125;) 使用管道实现： 123456789101112let fs = require('fs')// 创建一个输入的流，读取 readMe.txtlet myReadStream = fs.createReadStream(__dirname + '/readMe.txt');// 创建一个输出的流，修改 writeMe.txtlet myWriteStream = fs.createWriteStream(__dirname + '/writeMe.txt');// 使用管道myReadStream .pipe(myWriteStream) .on('finish',function()&#123; console.log('done'); &#125;) 可以看到，使用管道的话，只要一句话就可以读出 readMe.txt 的内容，然后给 writeMe.txt，结束后打印 ‘done’。 HTTP响应纯文本先来实现一个 server 123456789101112131415let http = require('http')// 创建一个 server，request =&gt; 请求,response =&gt; 响应，这两个参数实现一个流的实例let server = http.createServer(function(request,response)&#123; console.log('Request received'); // 响应第一个参数：状态码，第二个参数：响应内容的格式 response.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); // 响应的内容 response.write('hello from out application'); // 响应结束 response.end();&#125;)// 这个 server 在 3000 端口上监听server.listen(3000,'127.0.0.1');console.log('Server started on localhost port 3000') 此时打开浏览器，在 3000 端口上就可以看见响应的内容，在谷歌调试工具的 Network 可以看见请求信息。 在终端中可以看见启动服务后打印了 Server started on localhost port 3000，请求了一次 3000 端口后打印了 Request received，多次请求可以看见多次打印。 这样我们就创建了一个简单的服务器，并且响应了一个纯文本给浏览器。 响应 JSON响应 JSON 很简单，只要把响应内容的格式改成 application/json 就可以了： 123456789101112131415161718192021let http = require('http')let personObj = &#123; 'name':'make', 'age':'18', 'sex':'男'&#125;// 创建一个 server，request =&gt; 请求,response =&gt; 响应，这两个参数实现一个流的实例let server = http.createServer(function(request,response)&#123; console.log('Request received'); // 响应第一个参数：状态码，第二个参数：响应内容的格式 response.writeHead(200,&#123;'Content-Type':'application/json'&#125;); // 响应的内容，把 JSON 对象序列化成 string response.write(JSON.stringify(personObj)); // 响应结束 response.end();&#125;)// 这个 server 在 3000 端口上监听server.listen(3000,'127.0.0.1');console.log('Server started on localhost port 3000') 上面就响应了一个 JSON 给浏览器，同样的，浏览器可以在 3000 端口查看相应内容。 响应 HTML响应 html，把响应内容的格式改成 text/html 就可以了： 12345678910111213141516171819202122232425262728let http = require('http')let htmlFile = `&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;NI HAO!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;`// 创建一个 server，request =&gt; 请求,response =&gt; 响应，这两个参数实现一个流的实例let server = http.createServer(function(request,response)&#123; console.log('Request received'); // 响应第一个参数：状态码，第二个参数：响应内容的格式 response.writeHead(200,&#123;'Content-Type':'text/html'&#125;); // 响应的内容,响应一个 html response.write(htmlFile); // 响应结束 response.end();&#125;)// 这个 server 在 3000 端口上监听server.listen(3000,'127.0.0.1');console.log('Server started on localhost port 3000') 用流的形式读取页面并响应： 123456789101112131415161718let http = require('http')let fs = require('fs')// 创建一个输入的流，读取 index.html// createReadStream 第一个参数是地址，第二个参数是编码格式let myReadStream = fs.createReadStream(__dirname + '/index.html','utf8')// 创建一个 server，request =&gt; 请求,response =&gt; 响应，这两个参数实现一个流的实例let server = http.createServer(function(request,response)&#123; console.log('Request received'); // 响应第一个参数：状态码，第二个参数：响应内容的格式 response.writeHead(200,&#123;'Content-Type':'text/html'&#125;); // 响应的内容,响应一个 html(用管道的方式响应) myReadStream.pipe(response);&#125;)// 这个 server 在 3000 端口上监听server.listen(3000,'127.0.0.1');console.log('Server started on localhost port 3000') 上面就是读取了 index.html 页面，然后响应给了服务器。 如果我们在响应的内容格式那里写 texl/plain，则浏览器不会解析，而是直接显示。 模块化重构把上面的内容打包成一个模块： 12345678910111213141516171819202122let http = require('http')let fs = require('fs')function startServer() &#123; // 创建一个输入的流，读取 index.html // createReadStream 第一个参数是地址，第二个参数是编码格式 let myReadStream = fs.createReadStream(__dirname + '/index.html', 'utf8') // 创建一个 server，request =&gt; 请求,response =&gt; 响应，这两个参数实现一个流的实例 let server = http.createServer(function (request, response) &#123; console.log('Request received'); // 响应第一个参数：状态码，第二个参数：响应内容的格式 response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); // 响应的内容,响应一个 html(用管道的方式响应) myReadStream.pipe(response); &#125;) // 这个 server 在 3000 端口上监听 server.listen(3000, '127.0.0.1'); console.log('Server started on localhost port 3000')&#125;exports.startServer = startServer; 这个模块的文件名称是 server.js，然后我们可以在 app.js 中调用它： 123let server = require('./server')server.startServer() 在终端中执行 1node app 即可在浏览器的 3000 端口看到 index.html 的内容。 路由所谓的路由就是根据请求的 url 的不同，响应不同的页面。 基础我们可以通过 request.url 来获取请求的 url 并进行判断，重构一下之前的代码： 12345678910111213141516171819202122232425262728293031323334353637let http = require('http')let fs = require('fs')function startServer() &#123; let onRequest = function (request, response) &#123; // 通过 request.url 获取请求的 url console.log('Request received' + request.url); // 判断请求的 url，不同的 url 返回不同的内容 if (request.url === '/' || request.url === '/home') &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/index.html', 'utf8').pipe(response) &#125; else if (request.url === '/review') &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/review.html', 'utf8').pipe(response) &#125; else if (request.url === '/api/v1/records') &#123; response.writeHead(200, &#123; 'Content-Type': 'application/json' &#125;); let jsonObj = &#123; name:'july', sex:'女', age:'18' &#125; response.end(JSON.stringify(jsonObj)) &#125;else&#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/404.html', 'utf8').pipe(response) &#125; &#125; // 创建一个 server let server = http.createServer(onRequest) // 这个 server 在 3000 端口上监听 server.listen(3000, '127.0.0.1'); // 启动 server 后打印下面的内容 console.log('Server started on localhost port 3000')&#125;exports.startServer = startServer; 上面就对请求的 url 进行了判断，当请求不同的 url 的时候，会返回不同的内容。 重构路由上面的路由太繁琐了，严重影响阅读，我们可以对它进行一下重构。 首先，我们写一个 handler.js 模块： 123456789101112131415161718192021222324252627const fs = require('fs')function home(response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/index.html', 'utf8').pipe(response)&#125;function review(response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/review.html', 'utf8').pipe(response)&#125;function api_records(response) &#123; response.writeHead(200, &#123; 'Content-Type': 'application/json' &#125;); let jsonObj = &#123; name: 'july', sex: '女', age: '18' &#125; response.end(JSON.stringify(jsonObj))&#125;module.exports = &#123; home, review, api_records&#125; 这个模块就是把上面路由对应的判断写了进来，针对对应的 request.url 进行对应的返回，注意这里没有 404 的判断。我们把写的每一个判断都导出。 我们再写一个 router.js 模块来进行判断： 12345678910111213const fs = require('fs')function route(handle, pathname, response) &#123; console.log('Routeing a request for ' + pathname) if (typeof handle[pathname] === 'function') &#123; handle[pathname](response); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/404.html', 'utf8').pipe(response) &#125;&#125;module.exports.route = route; 这个模块会接收 handle，pathname，response，其中的 handle 是我们在 app.js 中对 handle.js 进行处理后传递过来的；pathname 就是 server.js 里面的 request.url；response 就是 server.js 里面的 response。 这里就是对 server 传递过来的 request.url 进行判断，如果在 handle 中有对应的 function，就执行，没有，就返回 404。 我们返回 app.js，修改如下： 1234567891011let server = require('./server')let router = require('./router')let handler = require('./handler')let handle = &#123;&#125;;handle['/'] = handler.home;handle['/home'] = handler.home;handle['/review'] = handler.review;handle['/api/v1/records'] = handler.api_records;server.startServer(router.route, handle) app.js 里面就导入了 handle 模块 和 router 模块，我们会在这里对 handle 模块进行处理。 定义了一个空对象 handle，然后把每一个 handler 对应的 function 都一一对应到 handle 中，把处理好的 handle 和 route 传递给 server 的 startServer 方法。 修改 server.js 如下： 123456789101112131415161718let http = require('http')let fs = require('fs')function startServer(route,handle) &#123; let onRequest = function (request, response) &#123; // 通过 request.url 获取请求的 url console.log('Request received' + request.url); route(handle,request.url,response); &#125; // 创建一个 server let server = http.createServer(onRequest) // 这个 server 在 3000 端口上监听 server.listen(3000, '127.0.0.1'); console.log('Server started on localhost port 3000')&#125;module.exports.startServer = startServer; 可以看到，现在的 server 就是接收 route 和 handle，所有的判断都交给 route 来做，对应的返回在 handle 中查找。 这样看起来我们的路由就很简单了，可读性也非常好。 使用 Get 和 PostGet 方法使用 Get 方法传递数据，是会把数据放在 url 后面，所有我们前面的路由那里也需要做一些处理，不能直接给 route 传递 request.url。 我们使用 node.js 的 url 库。 url 文档（中文） 这个库就是操作 url 的，我们可以通过它对 url 进行取值处理。 对 server.js 中的 onRequest 进行修改： 1let url = require('url') 12345678910let onRequest = function (request, response) &#123; // 通过这个方法来获取 url 的 ？前的内容 let pathname = url.parse(request.url).pathname; // 通过这个方法来获取 url 传递的参数 let params = url.parse(request.url,true).query; // 通过 pathname 获取请求的 url console.log('Request received' + pathname); // 把 url 和 参数都传递给 route route(handle,pathname,response,params); &#125; url.parse(request.url,true).query 的第一个参数是 url；第二个参数是 true，代表解析这个 url 并返回一个对象，如果是 false 就直接输出一个字符串。 url.parse 对应官方文档 对 router.js 进行修改： 1234567891011121314const fs = require('fs')function route(handle, pathname, response, params) &#123; console.log('Routeing a request for ' + pathname) if (typeof handle[pathname] === 'function') &#123; // 传递 response 和 url 的参数 handle[pathname](response, params); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); fs.createReadStream(__dirname + '/404.html', 'utf8').pipe(response) &#125;&#125;module.exports.route = route; 在 handler.js 中新建一个 function： 1234567891011function api_pass(response,params) &#123; response.writeHead(200, &#123; 'Content-Type': 'application/json' &#125;); response.end(JSON.stringify(params))&#125;module.exports = &#123; home, review, api_records, api_pass&#125; 修改 app.js 的 handle： 123456789101112let server = require('./server')let router = require('./router')let handler = require('./handler')let handle = &#123;&#125;;handle['/'] = handler.home;handle['/home'] = handler.home;handle['/review'] = handler.review;handle['/api/v1/records'] = handler.api_records;handle['/api/v1/pass'] = handler.api_pass;server.startServer(router.route, handle) 启动服务，在浏览器中输入： http://localhost:3000/api/v1/pass?id=4&amp;&amp;age=25 就可以看见返回的结果： 12&gt;&#123;&quot;id&quot;:&quot;4&quot;,&quot;age&quot;:&quot;25&quot;&#125;&gt; POST 方法上面的方法只能获取 Get 请求的数据，我们修改一些 server.js 以获取 post 请求的数据： 1let querystring = require('querystring') 1234567891011121314let onRequest = function (request, response) &#123; // 通过这个方法来获取 url 的 ？前的内容 let pathname = url.parse(request.url).pathname; // 通过 pathname 获取请求的 url console.log('Request received' + pathname); let data = ''; request.on('error', function (err) &#123; console.log(err) &#125;).on('data', function (chunk) &#123; data += chunk; &#125;).on('end', function () &#123; route(handle, pathname, response, querystring.parse(data)); &#125;) &#125; 这里是对 request 进行了一下判断，监听了 error，如果没有错误，就通过 data 获取数据，然后在 end 时调用了 route。 这里还对 data 做了一下处理，如果不这样处理，后面接收到的就是一个字符串，处理过后，接收到的就是一个 json 数据。 去修改一下 index.html： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;HELLO WORD!&lt;/div&gt; &lt;form action='/api/v1/records' method="POST"&gt; name:&lt;input type="text" name="name" /&gt; age:&lt;input type="text" name="age" /&gt; &lt;input type="submit" value="submit" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 加了一个表单，提交的路由是 /api/v1/records，所有修改一下 handler.js 的 api_records： 1234function api_records(response,params) &#123; response.writeHead(200, &#123; 'Content-Type': 'application/json' &#125;); response.end(JSON.stringify(params))&#125; 这样我们在主界面填写表单提交后就会在 http://localhost:3000/api/v1/records 页面看见表单的内容。 判断 Get 或 Post 请求上面能处理 post 但不能处理 get，所有我们这里判断一下不同的情况来进行不同的处理： 123456789101112131415161718192021let onRequest = function (request, response) &#123; // 通过这个方法来获取 url 的 ？前的内容 let pathname = url.parse(request.url).pathname; // 通过 pathname 获取请求的 url console.log('Request received' + pathname); let data = ''; request.on('error', function (err) &#123; console.log(err) &#125;).on('data', function (chunk) &#123; data += chunk; &#125;).on('end', function () &#123; // 判断是否是 post 请求 if (request.method === 'POST') &#123; route(handle, pathname, response, querystring.parse(data)); &#125; else &#123; // Get 方法取值 let params = url.parse(request.url, true).query; route(handle, pathname, response, params); &#125; &#125;) &#125; 这里就判断了一下 post，实际情况肯定不止这两种，还有 put 等等。 优化： 123456789101112131415161718192021222324252627let onRequest = function (request, response) &#123; // 通过这个方法来获取 url 的 ？前的内容 let pathname = url.parse(request.url).pathname; // 通过 pathname 获取请求的 url console.log('Request received' + pathname); // 定义的数组 let data = []; request.on('error', function (err) &#123; console.log(err) &#125;).on('data', function (chunk) &#123; data.push(chunk); &#125;).on('end', function () &#123; if (request.method === 'POST') &#123; // 如果数据很大，就取消这个请求（1e6：科学计数法，表示一个数字） if(data.length &gt; 1e6)&#123; request.connection.destroy(); &#125; // 处理 data data = Buffer.concat(data).toString(); route(handle, pathname, response, querystring.parse(data)); &#125; else &#123; // Get 方法取值 let params = url.parse(request.url, true).query; route(handle, pathname, response, params); &#125; &#125;) &#125; package.json我们使用一个项目的时候，如果没有 package.json 文件，可以通过 1$ npm init 来生成 package.json 文件。 其中的 dependencies 是所有安装的包的信息，通过 1$ npm install --save &lt;包名&gt; 安装的包会被记录在这里面。 其中的 devDependencies 是开发环境下需要使用的包的信息，通过 1$ npm install --save-dev &lt;包名&gt; 安装的包会被记录在这里面。 其中的 scripts 是定义的运行对应脚本的命令，例如： 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node app.js" &#125;, 通过在端上运行 app.js 就是： 1$ npm run start 有了 package.json，其他人如果用你的项目，通过运行 1$ npm install 可以下载项目需要的依赖的包，然后通过 1$ npm run start 运行。 当然，上面的都是 npm，现在也有用 yarn 的，方法都类似。 nodemon安装 nodemon 1$ npm install -g nodemon 它的作用是监控所有的文件，当你做了修改后自动重启服务器，这样就不用每次都自己手动重启服务器了。 使用 nodeman 来启动服务： 1$ nodeman app 启动后会显示 123456[nodemon] 1.19.3[nodemon] to restart at any time, enter `rs`[nodemon] watching dir(s): *.*[nodemon] watching extensions: js,mjs,json[nodemon] starting `node app.js`Server started on localhost port 3000 其中的最后一句（Server started on localhost port 3000）是我们定义在 server.js 中启动服务后打印的内容。 这样代码有改变的时候它会自动重启。 修改一下 package.json： 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "nodemon app.js" &#125;, 这样我们就可以通过 npm run start 来使用 nodemon 启动服务了。 这个工具在开发环境中使用，不要在生产环境中使用。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 构建组件的步骤与方法]]></title>
    <url>%2F2019%2F10%2F04%2FReact%E7%9A%84state%E4%B8%8Eprops%2F</url>
    <content type="text"><![CDATA[React 构建组件的步骤与方法 React 构建组件的步骤与方法一：将设计好的UI组件划分组件层级根据单一功能原则，来判断组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。 二：用 React 创建一个静态版本现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。 在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，不会用到它。 三：确定 UI state 的最小（且完整）表示想要使 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 state 来完成这个任务。 为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。比如，编写一个任务清单应用，只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当需要展示任务个数时，只需要利用该数组的 length 属性即可。 通过问自己以下三个问题，可以逐个检查相应数据是否属于 state： 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。 四：确定 state 放置的位置React 中的数据流是单向的，并顺着组件层级从上往下传递。 对于应用中的每一个 state： 找到根据这个 state 进行渲染的所有组件。 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。 该共同所有者组件或者比它层级更高的组件应该拥有该 state。 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。 五：添加反向数据流到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级中的 state。 参考 React 哲学]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React受控组件与非受控组件]]></title>
    <url>%2F2019%2F10%2F04%2FReact%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[React受控组件与非受控组件 受控组件在 HTML 中，表单元素（如&lt;input&gt;、 &lt;textarea&gt; 和 &lt;select&gt;）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。 我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。 在 React 中，、、之类的表单元素都是受控组件。 文件 input 标签是一个非受控组件： 非受控组件在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。 要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。 例如，下面的代码使用非受控组件接受一个表单的值： 123456789101112131415161718192021222324class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); this.input = React.createRef(); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.input.current.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type="text" ref=&#123;this.input&#125; /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/form&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确使用React State]]></title>
    <url>%2F2019%2F10%2F04%2F%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8React%20State%2F</url>
    <content type="text"><![CDATA[正确使用React State 正确使用React State关于 setState() 你应该了解三件事：不要直接修改 State例如，此代码不会重新渲染组件： 12// Wrongthis.state.comment = &apos;Hello&apos;; 而是应该使用 setState(): 12// Correctthis.setState(&#123;comment: &apos;Hello&apos;&#125;); 构造函数是唯一可以给 this.state 赋值的地方： State 的更新可能是异步的出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。 因为 this.props 和 this.state 可能会异步更新，所以不要依赖他们的值来更新下一个状态。 例如，此代码可能会无法更新计数器： 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数： 1234// Correctthis.setState((state, props) =&gt; (&#123; counter: state.counter + props.increment&#125;)); 上面使用了箭头函数，不过使用普通的函数也同样可以： 123456// Correctthis.setState(function(state, props) &#123; return &#123; counter: state.counter + props.increment &#125;;&#125;); State 的更新会被合并当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。 例如，你的 state 包含几个独立的变量： 1234567constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; 然后你可以分别调用 setState() 来单独地更新它们： 12345678910111213componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;);&#125; 这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期]]></title>
    <url>%2F2019%2F10%2F04%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React16 版本前与16版本后的生命周期。 React（后）生命周期生命周期图谱 简略生命周期图谱 详细生命周期图谱 原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。 原来（React v16.0前）的生命周期在render前执行的有： componentWillMount（已废除，被 getDerivedStateFromProps 替代） componentWillReceiveProps（已废除，被 getDerivedStateFromProps 替代） shouldComponentUpdate componentWillUpdate（已废除，被 getDerivedStateFromProps 替代） 如果开发者开了async rendering，而且又在以上这些 render 前执行的生命周期方法做 AJAX 请求的话，那 AJAX 将被无谓地多次调用。。。明显不是我们期望的结果。而且在 componentWillMount 里发起 AJAX，不管多快得到结果也赶不上首次 render，而且 componentWillMount 在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的 IO操作 放在 componentDidMount 里更合适。 禁止不能用比劝导开发者不要这样用的效果更好，所以除了 shouldComponentUpdate，其他在render函数之前的所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被 getDerivedStateFromProps 替代。 也就是用一个静态函数 getDerivedStateFromProps 来取代被 废弃的几个生命周期函数，就是强制开发者在 render 之前只做无副作用的操作，而且能做的操作局限在根据 props 和 state 决定新的 state。 getDerivedStateFromPropsgetDerivedStateFromProps 取代 componentWillMount、componentWillReceiveProps、componentWillUpdate。 getDerivedStateFromProps 无论是 Mounting 还是 Updating，也无论是因为什么引起的 Updating，全部都会被调用，它应该返回一个对象来更新状态，或者返回null来不更新任何内容。 getSnapshotBeforeUpdategetSnapshotBeforeUpdate() 在 render 之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个 snapshot，这个 snapshot 会作为 componentDidUpdate 的第三个参数传入，snapshot 可以是任何值。 12345678getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log('#enter getSnapshotBeforeUpdate'); return 'foo'; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log('#enter componentDidUpdate snapshot = ', snapshot); &#125; Mount（挂载）使用： constructor() static getDerivedStateFromProps() render() componentDidMount() 废弃： componentWillMount() Update（更新）使用： static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 废弃： componentWillReceiveProps() componentWillUpdate() Unmount（移除）使用： componentWillUnmount() 错误处理当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法： static getDerivedStateFromError() componentDidCatch() React16（前）生命周期生命周期图谱 初始化阶段也就是以下代码中类的构造方法( constructor() ),Test 类继承了 react Component 这个基类，也就继承这个 react 的基类，才能有 render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。 super(props)用来调用基类的构造方法( constructor() ), 也将父组件的 props 注入给子组件，功子组件读取(组件中 props 只读不可变，state 可变)。而 constructor() 用来做一些组件的初始化工作，如定义 this.state 的初始内容。 1234567import React, &#123; Component &#125; from 'react';class Test extends Component &#123; constructor(props) &#123; super(props); &#125;&#125; Mount（挂载） componentWillMount =&gt; render =&gt; componentDidMount componentWillMount（Mount 前）在组件挂载到DOM前调用，且只会被调用一次，在这边调用 this.setState 不会引起组件重新渲染，也可以把写在这边的内容提前到 constructor() 中，所以项目中很少用。 render根据组件的 props 和 state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新 render） ，return 一个 React 元素（描述组件，即UI），不负责组件实际渲染工作，之后由 React 自身根据此元素去渲染出页面 DOM。render 是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行 this.setState，会有改变组件状态的副作用（指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数）。 componentDidMount（Mount 后）组件挂载到DOM后调用，且只会被调用一次 Update（更新） componentWillReceiveProps =&gt; shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate 在讲述此阶段前需要先明确下 react 组件更新机制。setState 引起的 state 更新或父组件重新 render 引起的 props 更新，更新后的 state 和 props 相对之前无论是否有变化，都将引起子组件的重新 render。 造成组件更新有两类（三种）情况 父组件重新render 子组件显示父组件穿过来的props有两种方式： 直接使用 这种方式，父组件改变props后，子组件重新渲染，由于直接使用的props，所以我们不需要做什么就可以正常显示最新的props： 12345class Child extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.someThings&#125;&lt;/div&gt; &#125;&#125; 转换成自己的state 这种方式，由于我们使用的是state，所以每当父组件每次重新传递props时，我们需要重新处理下，将props转换成自己的state，这里就用到了 componentWillReceiveProps。 每次子组件接收到新的 props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的 props 更新 state，更新 state 也会触发一次重新渲染，但 react 不会这么傻，所以只会渲染一次，即官网的： 在该函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染。 1234567891011121314class Child extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; someThings: props.someThings &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setState(&#123;someThings: nextProps.someThings&#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.someThings&#125;&lt;/div&gt; &#125;&#125; 组件本身调用 setState，无论 state 有没有变化。可通过 shouldComponentUpdate 方法优化。 componentWillReceiveProps(nextProps)此方法只调用于 props 引起的组件更新过程中，参数 nextProps 是父组件传给当前组件的新 props。但父组件 render 方法的调用不能保证重传给当前组件的 props 是有变化的，所以在此方法中根据 nextProps 和 this.props 来查明重传的 props 是否改变，以及如果改变了要执行啥，比如根据新的 props 调用 this.setState 触发当前组件的重新 render。 shouldComponentUpdate(nextProps, nextState)此方法可以通过比较 nextProps，nextState 及当前组件的 this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。 ps：这边也可以看出，就算 componentWillReceiveProps() 中执行了 this.setState，更新了 state，但在 render 前（如 shouldComponentUpdate，componentWillUpdate），this.state 依然指向更新前的 state，不然 nextState 及当前组件的 this.state 的对比就一直是true了。 componentWillUpdate(nextProps, nextState)此方法在调用 render 方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。 renderrender方法在上文讲过，这边只是重新调用。 componentDidUpdate(prevProps, prevState)此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps 和 prevState 这两个参数指的是组件更新前的 props 和 state。 Unmount（卸载）componentWillUnmount此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚 componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。 参考 程墨Morgan老师的React v16.3之后的组件生命周期函数 详解React生命周期(包括react16版) React 官方文档]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios 基础.md]]></title>
    <url>%2F2019%2F10%2F04%2Faxios%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里主要介绍的是 axios 的基础 GETaxios.get()12345678axios.get('https://localhost:44322/api/user/get') .then((response) =&gt; &#123; console.log('原始get方法成功：') console.log(response.data);//请求的返回体 &#125;) .catch((error) =&gt; &#123; console.log(error);//异常 &#125;); methods 方法123456789101112axios( &#123; methods: 'get', url: 'https://localhost:44322/api/user/get', &#125;) .then((response) =&gt; &#123; console.log('methods方法成功：') console.log(response.data);//请求的返回体 &#125;) .catch((error) =&gt; &#123; console.log(error);//异常 &#125;); POSTmethods1234567891011121314151617let data = &#123; "name":"walk dog", "isComplete":true &#125; axios(&#123; method: "POST", headers:&#123;'Content-type':'application/json',&#125;, url: 'https://localhost:44305/api/Todo/PostTodoItem', data: data, &#125;) .then((response) =&gt; &#123; console.log('发送成功：') console.log(response.data);//请求的返回体 &#125;) .catch((error) =&gt; &#123; console.log(error);//异常 &#125;); .net Core 跨域设置在 Startup.cs 中，在 ConfigureServices 里面添加： 12// CORS 配置 services.AddCors(); 然后在 Configure 里面添加： 123456// CORS 配置 app.UseCors(builder =&gt; builder .AllowAnyOrigin() .AllowAnyMethod() .AllowAnyHeader() .AllowCredentials()); 注意，这个要写在 app.UseMvc(); 上面。]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Hooks基础用法]]></title>
    <url>%2F2019%2F10%2F02%2FReact-Hooks%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[React-Hooks 各类函数的用法。 react hooksuseStateuseState 是 react 自带的一个 hook 函数，它的作用就是用来声明状态变量。 useState 这个函数接收的参数是我们的状态初始值（initial state）， 它返回了一个数组，这个数组的第[0]项是当前的状态值， 第[1]项是可以改变状态值的方法函数。 1234567891011121314import React, &#123; useState &#125; from 'react';function Example() &#123; const [age, setAge] = useState(18); const [money, setMoney] = useState(1000); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; &#123; setAge(age + 1) &#125;&#125;&gt;&#123;age&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; setMoney(money + 1) &#125;&#125;&gt;&#123;money&#125;&lt;/button&gt; &lt;/div&gt; )&#125;export default Example; useEffect使用useEffect，可以直接在函数组件内处理生命周期事件。 如果你熟悉 React class 的生命周期函数， 你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合 useEffect 使用需要注意的地方 有两个参数 callback 和 dependencies 数组 如果 dependencies 不存在，那么 callback 每次 render 都会执行 如果 dependencies 存在，只有当它发生了变化， callback 才会执行 1234567891011121314151617181920import React, &#123; useEffect, useState &#125; from 'react';import ReactDOM from 'react-dom';function useEffectTest() &#123; useEffect(() =&gt; &#123; // 默认情况下，每次渲染后都会调用该函数 console.log('render!'); // 如果要实现 componentWillUnmount， // 在末尾处返回一个函数 // React 在该函数组件卸载前调用该方法 // 其命名为 cleanup 是为了表明此函数的目的， // 但其实也可以返回一个箭头函数或者给起一个别的名字。 return function cleanup () &#123; console.log('unmounting...'); &#125; &#125;) return "useEffectTest";&#125; 阻止每次重新渲染都会执行 useEffect 如果希望 effect 较少运行，可以提供第二个参数 - 值数组。 将它们视为该effect的依赖关系。 如果其中一个依赖项自上次更改后，effect将再次运行。 传入有数据的数组： 12345678910const [value, setValue] = useState(0);useEffect(() =&gt; &#123; // 仅在 value 更改时更新 console.log(value); // 仅在组件卸载时更新 return () =&gt; &#123; console.log('组件卸载'+&#123; value &#125;) &#125;&#125;, [value]) 传入空数组 12345678910const [value, setValue] = useState(0);useEffect(() =&gt; &#123; // 仅在第一次渲染时更新 console.log(value); // 仅在组件卸载时更新 return () =&gt; &#123; console.log('组件卸载'+&#123; value &#125;) &#125;&#125;, []) useContextuseContext 可以实现共享状态最大的改变是可以在使用 Counter 的时候不必在包裹 Children 了，比方说我们先创建一个上下文， 这个上下文里头有一个名为 count 的 state，以及一个修改 count 的方法 setCount 在父组件中，使用 createContext 创建上下文并导出，然后通过 value 传递给子组件 123456789101112131415161718import React, &#123; createContext, useState &#125; from 'react';import &#123; Counter &#125; from './Counter'// 创建一个上下文，这个上下文要导出export const CountContext = createContext()function UseContext() &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &#123;/* 使用创建的上下文，数据通过 value 传递给子组件，这里我们传递了一个对象 */&#125; &lt;CountContext.Provider value=&#123;&#123;count,setCount&#125;&#125;&gt; &lt;Counter /&gt; &lt;/CountContext.Provider&gt; &lt;/div&gt; )&#125;export default UseContext 在子组件中，导入父组件创建的上下文，然后使用 useContext 接收父组件通过 value 传递的值 12345678910111213import React, &#123; useContext &#125; from 'react';// 这里获取父组件的上下文import &#123; CountContext &#125; from './index'export function Counter() &#123; // 通过 useContext 获取父组件传递的内容(d对象解构) const &#123; count, setCount &#125; = useContext(CountContext) return ( &lt;div&gt; &lt;h2&gt;&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;count&lt;/button&gt; &lt;/div&gt; )&#125; useReducerRedux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态 简单来说 reducer 是一个函数 (state, action) =&gt; newState： 接收当前应用的 state 和触发的动作 action，计算并返回最新的state。 useReducer 的作用就是创建一个状态管理器，它接收一个 reducer 和初始的 state 的值。它返回了一个数组，这个数组的第[0]项是当前的 state， 第[1]项是可以改变 state 的方法函数 dispatch，它会传递一个 action 给状态管理器。 const [state, dispatch] = useReducer(reducer, initialState) 1234567891011121314151617181920212223242526272829import React, &#123; useReducer &#125; from 'react';// 创建的 reducerfunction reducer(state, action) &#123; switch (action.type) &#123; case 'add': return &#123; count: state.count + 1 &#125;; case 'del': return &#123; count: state.count - 1 &#125;; default: return state; &#125;&#125;function UseReducer() &#123; const initialState = &#123; count: 0 &#125; // 利用 reducer 和 初始state 创建一个状态管理器，返回 state 和 dispatch const [state, dispatch] = useReducer(reducer, initialState) return ( &lt;div&gt; &lt;p&gt;&#123;state.count&#125;&lt;/p&gt; &#123;/* 利用 dispatch 传递一个 action 给状态管理器 */&#125; &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;type:'add'&#125;)&#125;&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;type:'del'&#125;)&#125;&#125;&gt;del&lt;/button&gt; &lt;/div&gt; )&#125;export default UseReducer; 通过 useReducer 和 useContext 可以实现 redux，useReducer 创建状态管理器，useContext 将管理器传递给所有的子类（通过 useContext 传递 state 和 dispatch） useMemouseMemo 主要用来解决使用 React hooks 产生的无用渲染的性能问题。使用 function 的形式来声明组件，失去了 shouldCompnentUpdate （在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分 mount 和 update 两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。useMemo 和 useCallback 都是解决上述性能问题的。 React.memo() 是判断一个函数组件的渲染是否重复执行； useMemo() 是定义一段函数逻辑是否重复执行； useMemo(() =&gt; fn, inputs) 跟 useCallback(fn, inputs) 效果一样。 12345678910import React, &#123; useMemo &#125; from &apos;react&apos;;function UseMemo() &#123; // useMemo 接收两个参数，一个是 callback,第二个参数是一个数组，与 useEffect 类似 const increase = useMemo(() =&gt; &#123; if (value &gt; 2) return value + 1; &#125;, [value]);&#125;export default UseMemo; useRef 用useRef获取 React JSX 中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来作，React界面的变化可以通过状态来控制。 用useRef来保存变量， 渲染周期之间共享数据的存储（state不能存储跨渲染周期的数据，因为state的保存会触发组件重渲染），不过这个功能不多用，因为有了 useContext。 获取 DOM 节点 1234567891011121314151617181920import React, &#123; useEffect, useRef &#125; from 'react';function UseRef() &#123; // 定义一个 ref const h1Ref = useRef(); useEffect(() =&gt; &#123; // 输出获取到的DOM节点 console.log('useRef',h1Ref) &#125;, []) return ( &lt;div&gt; &#123;/*保存 h1 的ref到 h1Ref */&#125; &lt;h1 ref=&#123;h1Ref&#125;&gt;Hello World!&lt;/h1&gt; &lt;/div&gt; )&#125;export default UseRef;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章管理系统——前端（一）]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%96%87%E7%AB%A0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一个后台管理界面的前台 主要技术栈：react hooks + redux + immutable.js + antd 这一章主要讲依赖安装与 antd 配置 antd 文档：https://ant.design/docs/react/use-with-create-react-app-cn 依赖安装antd1$ yarn add antd 1$ yarn add react-app-rewired customize-cra 1$ yarn add babel-plugin-import 1$ yarn add less less-loader redux1$ yarn add redux 1$ yarn add react-redux axios1$ yarn add axios styled-components1$ yarn add styled-components redux-thunk1$ yarn add redux-thunk redux-immutable1$ yarn add redux-immutable react-router-dom1$ yarn add react-router-dom 使用 antd使用安装了 antd 后，在需要使用的地方导入： 12import 'antd/dist/antd.css';import Button from 'antd/es/button'; 就可以使用了，这里导入了 Button 做示例，但要注意，此时是导入的全部样式。 高级设置安装了 react-app-rewired 和 customize-cra 之后，修改 package.json： 1234567/* package.json */"scripts": &#123; "start": "react-app-rewired start", "build": "react-app-rewired build", "test": "react-app-rewired test", "eject": "react-scripts eject"&#125; 然后在项目根目录创建一个 config-overrides.js 用于修改默认配置： 1234module.exports = function override(config, env) &#123; // do stuff with the webpack config... return config;&#125;; 按需加载安装了 babel-plugin-import 后，修改 config-overrides.js 文件： 12345678const &#123; override, fixBabelImports &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: 'css', &#125;),); 然后移除前面导入的 import &#39;antd/dist/antd.css&#39;; 自定义主题安装了 less 和 less-loader 后，修改 config-overrides.js 文件如下： 123456789101112131415- const &#123; override, fixBabelImports &#125; = require('customize-cra');+ const &#123; override, fixBabelImports, addLessLoader &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es',- style: 'css',+ style: true, &#125;),+ addLessLoader(&#123;+ javascriptEnabled: true,+ modifyVars: &#123; '@primary-color': '#1DA57A' &#125;,+ &#125;),); 这里利用了 less-loader 的 modifyVars 来进行主题配置，变量和其他配置方式可以参考 配置主题 文档。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
        <tag>后台管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章管理系统——后端（一）]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%96%87%E7%AB%A0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[主要技术栈：.net Core 这一章主要讲 .net Core 的结构。 系统目录与功能分区 上面是后台管理系统的结构，我给它分了三层，其中 API 负责与前端交互，Domain 是领域层，负责处理业务逻辑，Data 是数据层，数据相关的都在里面。 在这个基础上，我又细分了多层： API：主项目层 Bussiness：业务逻辑层 IService：数据接口层 Service：数据层 Entity：实体层 Model：模型层 API：主项目层 这一层主要的就是 Controllers（控制器），它细分为 Admin 和 Client，这是为了以后扩展更方便。 Bussiness：业务逻辑层 同样的，这里也分为了 Admin 和 Client，这也是为了以后扩展更方便。 IService：数据接口层该层为数据接口层，里面只罗列了相应的接口函数，但是具体的函数功能实现则交给继承该数据接口的数据层来实现。 这样做的好处是可以将数据库操作与代码逻辑操作分离的更加清晰。 Service：数据层该层负责直接或者间接对数据库进行操作，如果你是用原生的或者类似Dapper的数据库中间件，那么在这一层就会看到相应的sql语句。我把 IService 给了 Domain，而 Service 给了 Data，因为前者处理业务逻辑，后者直接处理数据，当然，这是我第一次这样写，有不对的欢迎指正。 Entity：实体层该层为实体类层，存储了数据库对应的所有实体，实体一般和数据库表是一一对应的。我这里准备 EF 自动生成 Model：模型层该层我准备用作 Entity 的补充，刚从 MVC 过来，有点小习惯…… Service.Base：辅助层该层存放了一些系统帮助类，或是实体辅助类。 这个层还没确定建立……等以后再改吧。 数据库连接建立实体类在 Model 下面建立一个类，里面的内容与数据库表里的内容相对应。 例如我建立了一个 Role 表，则 Model 下面的类就是：RoleModel： 123456789101112using System;namespace AMS.Model&#123; public class RoleModel &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Description &#123; get; set; &#125; public int IsDelete &#123; get; set; &#125; &#125;&#125; 上下文类再在 Model 类库里面创建一个上下文类 CoreDbContext： 1234567891011121314151617181920using System;using System.Collections.Generic;using System.Text;using Microsoft.EntityFrameworkCore;namespace AMS.Model&#123; public class CoreDbContext : DbContext &#123; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123; if (!optionsBuilder.IsConfigured) &#123; optionsBuilder.UseSqlServer(@&quot;Data Source=.;Initial Catalog=XX_AMS;Integrated Security=True&quot;); &#125; &#125; public virtual DbSet&lt;RoleModel&gt; T_Role &#123; get; set; &#125; &#125;&#125; CoreDbContext 类继承 DbContext，DbContext是EF框架中非常重要的一个环节，是建立实体类与数据库连接的桥梁。 这里我们写了连接数据库的字符串，同时把 RoleModel 给了它，这样我们就连接到数据库了。 控制器在 Controllers/Admin 下面新建一个 RoleController.cs 控制器，里面写入： 1234567891011121314151617181920using System;using System.Collections.Generic;using System.Text;using Microsoft.EntityFrameworkCore;namespace AMS.Model&#123; public class CoreDbContext : DbContext &#123; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123; if (!optionsBuilder.IsConfigured) &#123; optionsBuilder.UseSqlServer(@&quot;Data Source=.;Initial Catalog=XX_AMS;Integrated Security=True&quot;); &#125; &#125; public virtual DbSet&lt;RoleModel&gt; T_Role &#123; get; set; &#125; &#125;&#125; 这里使用了 Model 里面的类容，所有我们要把 Model 的引用 API 里面，然后直接运行，定位到 admin/role/RoleGetList 就可以在浏览器中查看结果了。 数据库连接优化将连接字符串写入 API 下面的 appsettings.json，其代码修改如下： 1234567891011&#123; "Logging": &#123; "LogLevel": &#123; "Default": "Warning" &#125; &#125;, "AllowedHosts": "*", "connectionStrings": &#123; "conn": "Data Source=.;Initial Catalog=XX_AMS;Integrated Security=True" &#125;&#125; 然后去修改 Startup.cs，将里面 ConfigureServices 的添加： 12services.AddDbContext&lt;CoreDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString(&quot;conn&quot;))); 修改上下文类为： 12345678910111213141516using System;using System.Collections.Generic;using System.Text;using Microsoft.EntityFrameworkCore;namespace AMS.Model&#123; public class CoreDbContext : DbContext &#123; public CoreDbContext(DbContextOptions&lt;CoreDbContext&gt; options) : base(options) &#123; &#125; public virtual DbSet&lt;RoleModel&gt; T_Role &#123; get; set; &#125; &#125;&#125; 这时其实是已经把coreDbContext注入到容器中进行操作，而容器中对Context的注入方式为瞬时注入，因此后面要用到依赖注入的时候，很多时候，在数据层使用context的时候需要把对应的注入都设计为瞬时注入的形式，此处就不进行过多的提及。 我们在进行测试一下，这下我们就不用自己进行context的new操作，由于我们一开始进行设置的时候就已经进行了依赖注入的形式，不过，.netCore中只有构造注入，没有属性注入，因此我们就用构造注入的方式进行，修改 RoleController.cs 如下： 123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using AMS.Model;using Microsoft.AspNetCore.Http;using Microsoft.AspNetCore.Mvc;using Microsoft.EntityFrameworkCore;namespace AMS.API.Controllers.Admin&#123; [Route(&quot;admin/[controller]/[action]&quot;)] [ApiController] public class RoleController : ControllerBase &#123; private readonly CoreDbContext _coreDbContext; public RoleController(CoreDbContext coreDbContext) &#123; _coreDbContext = coreDbContext; &#125; [HttpGet] public List&lt;RoleModel&gt; RoleGetList() &#123; return _coreDbContext.Set&lt;RoleModel&gt;().ToList(); &#125; &#125;&#125; 我们使用构造函数进行构造注入。然后直接使用 ToList() 获取所有的数据。 直到这里，我们已经能够在 /admin/role/RoleGetList 里面看到我们获取到的所有数据了。 CORS 配置最后的最后，我们进行一下 CORS 配置，在 API 的 Startup.cs 的 ConfigureServices 写入： 1services.AddCors(); 然后在 Configure 里面写入： 123456app.UseCors(builder =&gt; builder .AllowAnyOrigin() .AllowAnyMethod() .AllowAnyHeader() .AllowCredentials());app.UseMvc(); 当然，这里配置的是允许全部，你也可以针对性的配置，详情可看 https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-2.2，我这里就这样配置了，以后再改。 swagger使用 seagger使用 swagger 来查看 api： 在 API 的 Startup.cs 的 ConfigureServices 中写入： 123456789101112#region Swagger services.AddSwaggerGen(c =&gt; &#123; c.SwaggerDoc(&quot;v1&quot;, new Info &#123; Version = &quot;v0.1.0&quot;, Title = &quot;Blog.Core API&quot;, Description = &quot;框架说明文档&quot;, TermsOfService = &quot;None&quot;, &#125;); &#125;); #endregion 在 API 的 Startup.cs 的 Configure 中写入： 1234567#region Swagger app.UseSwagger(); app.UseSwaggerUI(c =&gt; &#123; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;ApiHelp V1&quot;); &#125;); #endregion 修改 swagger 为启动页，在 API 的 Properties 的 launchSettings.json 里面修改 profiles 的 IIS Express 中的 launchUrl 为 swagger，此时启动页面就可以看到效果了。 显示注释在 api 的属性 =&gt; 生成 =&gt; 输出，勾选 XML 文档文件，打开输出，根据提示给各个方法添加注释。 然后去修改 Startup.cs： 123456789101112131415161718192021#region Swagger services.AddSwaggerGen(c =&gt; &#123; c.SwaggerDoc(&quot;v1&quot;, new Info &#123; Version = &quot;v0.1.0&quot;, Title = &quot;AMS.Core.API API&quot;, Description = &quot;API说明文档&quot;, TermsOfService = &quot;None&quot;, Contact = new Swashbuckle.AspNetCore.Swagger.Contact &#123; Name = &quot;AMS.Core&quot;, Email = &quot;2533566560@qq.com&quot;, Url = &quot;https://lemonsea.github.io/&quot; &#125; &#125;); // 显示注释 // Core 2.0 var basePath = PlatformServices.Default.Application.ApplicationBasePath; // Core 2.1 //var basePath = Microsoft.DotNet.PlatformAbstractions.ApplicationEnvironment.ApplicationBasePath; var xmlPath = Path.Combine(basePath, &quot;AMS.Core.API.xml&quot;);//这个就是刚刚配置的xml文件名 c.IncludeXmlComments(xmlPath, true);//默认的第二个参数是false，这个是controller的注释，记得修改 &#125;); #endregion 在启动服务就可以看见每个 api 后面都有我们写的注释了。 自动生成实体1Scaffold-DbContext -Connection "Data Source=.;Initial Catalog=XX_AMS;Integrated Security=True" -Provider "Microsoft.EntityFrameworkCore.SqlServer" -OutputDir Models 更新表： 1Scaffold-DbContext -Connection "Data Source=.;Initial Catalog=XX_AMS;Integrated Security=True" -Provider "Microsoft.EntityFrameworkCore.SqlServer" -OutputDir Models -Force]]></content>
      <categories>
        <category>.net</category>
      </categories>
      <tags>
        <tag>后台管理系统</tag>
        <tag>.net Core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章管理系统——前端（二）]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%96%87%E7%AB%A0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%89%8D%E7%AB%AF%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一个后台管理界面的前台 主要技术栈：react hooks + redux + immutable.js + antd 这一章主要讲 redux 结构与 login 的 UI src 目录改造1234567891011├─api // 网路请求代码、工具类函数和相关配置├─assets // 字体配置及全局样式├─components // 非路由组件├─pages // 路由组件├─routes // 路由配置文件└─store // redux相关文件└─utils // 工具模块 App.js // 根组件 index.js // 入口文件 serviceWorker.js // PWA离线应用配置 style.js // 默认样式 重写 App.js在 pages 文件夹下创建两个文件夹：login 和 main。 分别在两个文件夹下创建 index.js 和 style.less，里面写入： 12345678910import React from 'react';import &#123; Button &#125; from 'antd';function Main()&#123; return( &lt;Button&gt;Main&lt;/Button&gt; )&#125;export default React.memo(Main) login 的 index.js 改一下就行了。 在 App.js 中导入路由： 123import &#123; BrowserRouter as Router, Route &#125; from 'react-router-dom';import Login from './pages/login';import Main from './pages/main'; 使用路由： 123456return ( &lt;Router&gt; &lt;Route path='/login' component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path='/' exact component=&#123;Main&#125;&gt;&lt;/Route&gt; &lt;/Router&gt; ); 现在就可以看见效果了。 使用 redux创建总仓库在 url 的 store 里面，创建 reducer.js 和 index.js，其中reducer.js 代码如下： 123456// 合并 reducer 函数import &#123; combineReducers &#125; from 'redux-immutable';// 合并 reducer 函数为一个 objexport default combineReducers(&#123;&#125;) 这里创建了一个总 reducer，同时我们使用 redux-immutable 的 combineReducers 来对各组件的 reducer 进行整合。 之后在 index.js 中的代码： 123456789101112import &#123; createStore, compose, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducer';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk)))export default store; 这个代码使用 createStore 创建了总的仓库，使用中间件 thunk，启用了 chrome 的插件 Redux。 创建分仓库在 pages 文件夹下的 login 文件夹中创建文件夹 store，里面创建四个文件：导出变量的index.js、管理数据的 reducer.js、管理变量的 constants.js、管理 action 的 actionCreators.js，其中，在 reducer.js 中写入： 123456789101112131415// 获取常量import * as actionTypes from './constants';// 导入 immutable 的 frmoJS 方法import &#123; fromJS &#125; from 'immutable';// 这里用到fromJS把JS数据结构转化成immutable数据结构const defaultState = fromJS(&#123;&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125; 这就创好了 reducer.js 的基础结构，然后在 index.js 中写入： 1234567// 导入仓库import reducer from './reducer'// 导入变量import * as actionCreators from './actionCreators'// 导出变量export &#123; reducer, actionCreators &#125;; 其他两个文件用时再改。其中 ajax 请求以及后续数据处理的具体代码全部放在 actionCreator 中，由 redux-thunk 进行处理，尽可能精简组件代码。 以后每个需要处理数据的组件都按照上面的结构写。 合并分仓库到总仓库去修改 src/store/ 下的 reducer.js： 123456789// 合并 reducer 函数import &#123; combineReducers &#125; from 'redux-immutable';// 导入分仓库的 reducerimport &#123; reducer as loginReducer &#125; from '../pages/login/store';// 合并 reducer 函数为一个 objexport default combineReducers(&#123; login: loginReducer&#125;) 这样就把 login 里的数据放进总仓库了，可以在 chrome 的 Redux 查看。 以后每个每一个容器组件都有自己独立的 reducer，然后再全局的 store 下通过 redux 的 combineReducer 方法合并。 写 Login 的 UI123456&#123; success:true; message：""; data:[&#123;&#125;]&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>前端</tag>
        <tag>后台管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（七）]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲 Recommend 的性能优化：图片懒加载，与 Loading 动画。 图片懒加载视口内图片加载我们使用一个成熟的图片懒加载库：react-lazyload 来做我们的图片懒加载。 安装： 1$ npm install react-lazyload --save 在需要使用的地方导入它，这里我们是在 components/list/index.js 中导入的： 1import LazyLoad from "react-lazyload"; 这里懒加载的原理是：在大量图片加载的情况下，会造成页面空白甚至卡顿，然而我们的视口就这么大，因此只需要让视口内的图片显示即可，同时图片未显示的时候给它一个默认的src，让一张非常精简的图片占位。这就是图片懒加载的原理。 所以，我们对 img 标签进行改造： 1234//img标签外部包裹一层LazyLoad&lt;LazyLoad placeholder=&#123;&lt;img width="100%" height="100%" src=&#123;require('./music.png')&#125; alt="music"/&gt;&#125;&gt; &lt;img src=&#123;item.picUrl + "?param=300x300"&#125; width="100%" height="100%" alt="music"/&gt;&lt;/LazyLoad&gt; 我们给 img 外面包裹了一层 LazyLoad，它会有一个占位图片 music.png，这个图片可以去相应分支拿。 现在我们做到了视口内的图片显示真实资源，视口外则显示占位图片。接下来要解决的就是当我们滑动时，记载新进入视口的图片。 滑动加载图片这个懒加载库提供了一个滑动加载图片的方法：forceCheck，只需要在 Recommend/index.js 中使用它就行了： 给 Scroll 组件的 onScroll 传入 forceCheck： 1&lt;Scroll className="list" onScroll=&#123;forceCheck&#125;&gt; 这里的 onScroll 是我们之前写 Scroll 组件就预设好了的方法。 至此，图片懒加载完成。 进场loading效果制作动画效果Ajax请求往往需要一定的时间，在这个时间内，页面会处于没有数据的状态，也就是空白状态，但是用户点击来的时候看见一片空白的时候心里是非常焦灼的，尤其是Ajax的请求时间长达几秒的时候，而loading效果便能减缓这种焦急的情绪，并且如果loading动画做的漂亮，还能够让人赏心悦目，让用户对App产生好感。 这个 Loading 动画，主要是利用了CSS3的animation-lay特性，让两个圆交错变化，产生一个涟漪的效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import styled,&#123; keyframes &#125; from 'styled-components';import style from '../../assets/global-style';const loading = keyframes` 0%,100% &#123; transform: scale(0.0); &#125; 50% &#123; transform: scale(1.0); &#125;`const LoadingWrapper = styled.div` &gt;div &#123; position: fixed; left: 0; right: 0; top: 0; bottom: 0; margin: auto; width: 1.6rem; height: 1.6rem; /* 不透明级 */ opacity: 0.6; border-radius: 50%; background-color: $&#123;style["theme-color"]&#125;; animation: $&#123;loading&#125; 1.4s infinite ease-in; &#125; &gt;div:nth-child(2) &#123; /* 定义动画何时开始 */ animation-delay: -0.7s; &#125;`;function Loading() &#123; return ( &lt;LoadingWrapper&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/LoadingWrapper&gt; );&#125;export default React.memo(Loading) 在 Recommend 组件中使用它： 1234567import Loading from '../../baseUI/loading/index';//在返回的JSX代码中&lt;Content&gt; ... &lt;Loading&gt;&lt;/Loading&gt;&lt;Content&gt; 此时可以看见一个涟漪在屏幕中间跳动。 添加Loading的控制逻辑现在 Loading 的动画效果一直都在，但我们要让它随我们的需求来出现和隐藏。我们在 Recommend 的 redux 中加一个控制器： 1234const defaultState = fromJS(&#123; ... enterLoading: true&#125;); 然后在 constants.js 中添加常量： 123//constants.js...export const CHANGE_ENTER_LOADING = 'recommend/CHANGE_ENTER_LOADING'; 在 actionCreators.js 中添加 action 以及修改 getRecommendList： 1234567891011121314151617//actionCreators.js...export const changeEnterLoading = (data) =&gt; (&#123; type: actionTypes.CHANGE_ENTER_LOADING, data&#125;);//另外在获取推荐歌单后，应把loading状态改为falseexport const getRecommendList = () =&gt; &#123; return (dispatch) =&gt; &#123; getRecommendListRequest().then(data =&gt; &#123; dispatch(changeRecommendList(data.result)); dispatch(changeEnterLoading(false));//改变loading &#125;).catch(() =&gt; &#123; console.log("推荐歌单数据传输错误"); &#125;); &#125;&#125;; 返回去给 reducer 添加一个逻辑： 12case actionTypes.CHANGE_ENTER_LOADING: return state.set('enterLoading', action.data); 最后在 Recommend/index.js 中使用： 1234567891011121314//recommend/index.jsconst &#123; bannerList, recommendList, enterLoading &#125; = props;//返回的JSX代码中应用它&lt;Content&gt; ... &#123; enterLoading ? &lt;Loading&gt;&lt;/Loading&gt; : null &#125;&lt;Content&gt; // 获取数据const mapStateToProps = (state) =&gt; (&#123; ... enterLoading: state.getIn(['recommend', 'enterLoading'])&#125;); 至此，Loading 动画完成。 Redux数据缓存问题:其实还有一个细节需要我们来优化，就是你现在切换到歌手页面，然后切回到推荐页，你在浏览器的Network中会看到又发了两次网络请求，而这两次请求是完全没有必要的，纯属浪费性能。 那如何来优化呢？根据我们这个项目的特点，利用Redux的数据来进行页面缓存成本最低，是不二之选。 其实操作起来也是非常简单的, 只需要做一些小小的改动：修改一下 Recommend/index.js 界面的 useEffect: 123456789101112//Recommend/index.jsuseEffect(() =&gt; &#123; // 如果页面有数据，则不发请求 // immutable数据结构中长度属性size if(!bannerList.size)&#123; getBannerDataDispatch(); &#125; if(!recommendList.size)&#123; getRecommendListDataDispatch(); &#125; // eslint-disable-next-line&#125;, []); 我们加了一个判断，如果如果页面有数据，则不发请求。 至此，我们的 Recommend 组件就彻底完成了。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（六）]]></title>
    <url>%2F2019%2F09%2F12%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲 axios 与 redux 的数据层开发。 axios 封装请求安装 axios1$ npm install axios --save 因为这个项目用的是被人写的 node.js 项目提供 api，所以先去 GitHub 上面 clone 这个项目：GitHub网易云音乐接口，然后把它运行在其他端口上，保证不和当前前端服务端口冲突。 配置 axios关于 api 的调用我们写在 api 文件夹里，在这个文件夹下面创建 config.js 文件，里面编写 axios 的配置: 12345678910111213141516171819202122import axios from 'axios';export const baseUrl = 'http://localhost:4000';// 创建axios的实例const axiosInstance = axios.create(&#123; baseURL: baseUrl&#125;);// 响应拦截器【响应拦截器的作用是在接收到响应后进行一些操作】axiosInstance.interceptors.response.use( // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 res =&gt; res.data, // 服务器状态码不是2开头的的情况 err =&gt; &#123; console.log(err, "网络错误"); &#125;);export &#123; axiosInstance&#125;; 这个是 axios 的实例配置，它会在所有请求前方加上 http://localhost:3300，即让所有数据从这个端口号请求。 本来还应该有下面的配置的： 123456timeout: 5000， // request timeout 设置请求超时时间responseType: "json",withCredentials: true, // 是否允许带cookie这些headers: &#123; "Content-Type": "application/json;charset=utf-8"&#125; 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如：如果后台返回的状态码是2开头的，则正常返回数据。 封装不同的网络请求在 api 文件夹下创建 request.js 文件，这个文件就封装不同的网络请求： 123456789import &#123; axiosInstance &#125; from "./config";export const getBannerRequest = () =&gt; &#123; return axiosInstance.get('/banner');&#125;export const getRecommendListRequest = () =&gt; &#123; return axiosInstance.get('/personalized');&#125; 这里封装了需要的两个接口，到时候直接调这些函数即可。 reudx 开发在 Recommend 目录下，新建 store 文件夹，然后新建以下文件： 1234actionCreators.js // 放不同action的地方constants.js // 常量集合，存放不同action的type值index.js // 用来导出reducer，actionreducer.js // 存放initialState和reducer函数 这是很自然的分离，如果用 rudex 的话，一般都会选择这样创建 reudx 结构。 这里是创建的 Recommend 组件的 store，然后我们会把它整合到整体的 store 中，即 src 的 store 中。 初始化 reducer：在 Recommend 的 store/reducer.js 中写入如下代码，这就是一开始的 reducer 文件的内容： 123456789101112131415// 获取常量import * as actionTypes from './constants';// 导入 immutable 的 frmoJS 方法import &#123; fromJS &#125; from 'immutable';// 这里用到fromJS把JS数据结构转化成immutable数据结构const defaultState = fromJS(&#123;&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125; 理所当然，此时的 constants.js 和 actionCreators.js 中还没有任何的内容。 链接到主仓库既然定义了 reducer，就需要把它链接到主仓库 src/store/reducer.js 中去，我们这里使用 Recommend/store/index.js 文件来做导出，在里面写入下面的代码： 1234567// 导入仓库import reducer from './reducer'// 导入变量import * as actionCreators from './actionCreators'// 导出变量export &#123; reducer, actionCreators &#125;; 然后去 src/reducer.js 中导入 Recommend/store/reducer/js 并合并： 123456789// 合并 reducer 函数import &#123; combineReducers &#125; from 'redux-immutable';// 导入分仓库的 reducerimport &#123; reducer as recommendReducer &#125; from '../application/Recommend/store/index';// 合并 reducer 函数为一个 objexport default combineReducers(&#123; recommend: recommendReducer,&#125;) 使用 connect去 Recommend/index.js 中导入 1234// 负责将 ui 组件包装成容器组件import &#123; connect &#125; from "react-redux";// 导入常量import * as actionCreaters from './store/actionCreators'; connect 的使用方法是： 12345678910// 映射Redux全局的state到组件的props上const mapStateToProps = (state) =&gt; &#123;&#125;// 映射dispatch到props上const mapDispatchToProps = (dispatch) =&gt; &#123;&#125;// 将ui组件包装成容器组件export default connect(mapStateToProps, mapDispatchToProps)(React.memo(Recommend)) 修改 reducer首先是在 Recommend/store/reducer.js 中创建 bannerList 和 recommendList： 1234567891011121314151617// 获取常量import * as actionTypes from './constants';// 导入 immutable 的 frmoJS 方法import &#123; fromJS &#125; from 'immutable';// 这里用到fromJS把JS数据结构转化成immutable数据结构const defaultState = fromJS(&#123; bannerList: [], recommendList: [],&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125; 然后在 constants 中定义常量： 1234//constants.jsexport const CHANGE_BANNER = 'recommend/CHANGE_BANNER';export const CHANGE_RECOMMEND_LIST = 'recommend/RECOMMEND_LIST'; 再重新定义 reducer 函数： 12345678910export default (state = defaultState, action) =&gt; &#123; switch(action.type) &#123; case actionTypes.CHANGE_BANNER: return state.set('bannerList', action.data); case actionTypes.CHANGE_RECOMMEND_LIST: return state.set('recommendList', action.data); default: return state; &#125;&#125; index 中获取 redux 的数据去 Recommend/index.js 中修改，我们先把之前的 mock 的数据删除了，换上重 redux 中获取的数据： 这里就需要使用我们之前的 mapStateToProps 方法了： 123456// 映射Redux全局的state到组件的props上const mapStateToProps = (state) =&gt; (&#123; // 不要再这里将数据toJS,不然每次diff比对props的时候都是不一样的引用，还是导致不必要的重渲染, 属于滥用immutable bannerList: state.getIn(['recommend', 'bannerList']), recommendList: state.getIn(['recommend','recommendList']),&#125;) getIn 是用来指定获取哪一个子 reducer 里的哪一个数据的，因为我们获取数据还是要通过全局的 src/reducer.js 来获取，所以我们要用这种方法指定数据的位置。getIn 的参数是一个数组，数组的第一个元素是在 src/recuder.js 中我们给 Recommend/store/reducer.js 命的名，第二个参数是 Recommend/store/reducer.js 中对应数据的名称。 把之前的 mock 数据改为下面的： 12345// 对象结构const &#123; bannerList, recommendList &#125; = props;// 把 immutable 数据类型转换为对应的 js 数据类型const bannerListJS = bannerList ? bannerList.toJS() : [];const recommendListJS = recommendList ? recommendList.toJS() :[];`` 这里我们要转一下获取到的数据的数据类型，因为我们 redux 中是 immutable 数据，而我们能使用的是 js 数据。 理所当然，我们的传递给子组件的数据也要修改一下： 12345678910return ( &lt;Content&gt; &lt;Scroll className="list"&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerListJS&#125;&gt;&lt;/Slider&gt; &lt;List recommendList=&#123;recommendListJS&#125;&gt;&lt;/List&gt; &lt;/div&gt; &lt;/Scroll&gt; &lt;/Content&gt; ) 此时如果 redux 中有数据，我们就已经获取到了，可是现在 redux 中还没有数据，所以接下来我们用 axios 来获取数据。 定义 axios 获取数据的函数去 actionCreators.js 中写下如下代码： 123456// 导入常量import * as actionTypes from './constants';// 将JS对象转换成immutable对象import &#123; fromJS &#125; from 'immutable';// 导入网络请求import &#123; getBannerRequest, getRecommendListRequest &#125; from '../../../api/request'; 通过 axios 获取轮播图的数据： 12345678910// 获取轮播图数据export const getBannerList = () =&gt; &#123; return (dispatch) =&gt; &#123; getBannerRequest().then(data =&gt; &#123; dispatch(changeBannerList(data.banners)); &#125;).catch(() =&gt; &#123; console.log("轮播图数据传输错误"); &#125;) &#125;&#125;; 这里使用了之前定义的网络请求 getBannerRequest，所以它完整的请求路径其实是：http://localhost:4000/banner。 然后定义 changeBannerList，它是用来获取到数据后定义要传送给 redux 的数据的格式的： 1234export const changeBannerList = (data) =&gt; (&#123; type: actionTypes.CHANGE_BANNER, data: fromJS(data)&#125;); 传给 redux 的数据格式是 type 和 data，type 是我们定义的常量，而 data 因为我们获取的是 js 数据的原因，这里要先转成 immutable 数据格式才能给 redux 使用。 用同样的写法获取推荐列表的数据，下面是整个 actionCreators 的代码： 12345678910111213141516171819202122232425262728293031323334353637// 导入常量import * as actionTypes from './constants';// 将JS对象转换成immutable对象import &#123; fromJS &#125; from 'immutable';// 导入网络请求import &#123; getBannerRequest, getRecommendListRequest &#125; from '../../../api/request';export const changeBannerList = (data) =&gt; (&#123; type: actionTypes.CHANGE_BANNER, data: fromJS(data)&#125;);export const changeRecommendList = (data) =&gt; (&#123; type: actionTypes.CHANGE_RECOMMEND_LIST, data: fromJS(data)&#125;);// 获取轮播图数据export const getBannerList = () =&gt; &#123; return (dispatch) =&gt; &#123; getBannerRequest().then(data =&gt; &#123; dispatch(changeBannerList(data.banners)); &#125;).catch(() =&gt; &#123; console.log("轮播图数据传输错误"); &#125;) &#125;&#125;;export const getRecommendList = () =&gt; &#123; return (dispatch) =&gt; &#123; getRecommendListRequest().then(data =&gt; &#123; dispatch(changeRecommendList(data.result)); &#125;).catch(() =&gt; &#123; console.log("推荐歌单数据传输错误"); &#125;); &#125;&#125;; 在 Recommend 中使用获取数据的函数首先拿到我们获取数据的方法，这里就用到了 mapDispatchToProps： 1234567891011// 映射dispatch到props上const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; getBannerDataDispatch() &#123; dispatch(actionCreaters.getBannerList()); &#125;, getRecommendListDataDispatch() &#123; dispatch(actionCreaters.getRecommendList()); &#125;, &#125;&#125; 然后使用它： 12345678// 对象解构const &#123; getBannerDataDispatch, getRecommendListDataDispatch &#125; = props;// 当传空数组([])时，只会在组件 mount 时执行内部方法。useEffect(() =&gt; &#123; getBannerDataDispatch(); getRecommendListDataDispatch();&#125;, []); 以上，有了获取数据的方法，有了使用数据的方法，只要启动GitHub网易云音乐接口，然后把它运行在其他端口上，并在 api/config.js 中的 baseUrl 配置成你运行的端口号，那么我们的页面数据应该已经可以正常使用了。 总结Recommend/index.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; useEffect &#125; from 'react';import Slider from '../../components/slider';import List from '../../components/list';import Scroll from '../../baseUI/scroll';import styled from 'styled-components';import &#123; connect &#125; from "react-redux";import * as actionCreaters from './store/actionCreators';export const Content = styled.div` position: fixed; top: 2.4rem; bottom: 0; width: 100%; max-width: 750px;`function Recommend(props) &#123; // const bannerList = [1, 2, 3, 4].map(item =&gt; &#123; // return &#123; imageUrl: "http://p1.music.126.net/ZYLJ2oZn74yUz5x8NBGkVA==/109951164331219056.jpg" &#125; // &#125;) // const recommendList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((item, index) =&gt; &#123; // return &#123; // id: index, // picUrl: "https://p1.music.126.net/fhmefjUfMD-8qtj3JKeHbA==/18999560928537533.jpg", // playCount: 17171122, // name: "[洗澡时听的歌] 浴室里听歌吹泡泡o○o○o○" // &#125; // &#125;); const &#123; bannerList, recommendList &#125; = props; const bannerListJS = bannerList ? bannerList.toJS() : []; const recommendListJS = recommendList ? recommendList.toJS() : []; const &#123; getBannerDataDispatch, getRecommendListDataDispatch &#125; = props; useEffect(() =&gt; &#123; getBannerDataDispatch(); getRecommendListDataDispatch(); &#125;, []); return ( &lt;Content&gt; &lt;Scroll className="list"&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerListJS&#125;&gt;&lt;/Slider&gt; &lt;List recommendList=&#123;recommendListJS&#125;&gt;&lt;/List&gt; &lt;/div&gt; &lt;/Scroll&gt; &lt;/Content&gt; )&#125;// 映射Redux全局的state到组件的props上const mapStateToProps = (state) =&gt; (&#123; // 不要再这里将数据toJS,不然每次diff比对props的时候都是不一样的引用，还是导致不必要的重渲染, 属于滥用immutable bannerList: state.getIn(['recommend', 'bannerList']), recommendList: state.getIn(['recommend', 'recommendList']),&#125;)// 映射dispatch到props上const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; getBannerDataDispatch() &#123; dispatch(actionCreaters.getBannerList()); &#125;, getRecommendListDataDispatch() &#123; dispatch(actionCreaters.getRecommendList()); &#125;, &#125;&#125;// 将ui组件包装成容器组件export default connect(mapStateToProps, mapDispatchToProps)(React.memo(Recommend)) Recommend/store/reducer.js123456789101112131415161718192021// 获取常量import * as actionTypes from './constants';// 导入 immutable 的 frmoJS 方法import &#123; fromJS &#125; from 'immutable';// 这里用到fromJS把JS数据结构转化成immutable数据结构const defaultState = fromJS(&#123; bannerList: [], recommendList: [],&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case actionTypes.CHANGE_BANNER: return state.set('bannerList', action.data); case actionTypes.CHANGE_RECOMMEND_LIST: return state.set('recommendList', action.data); default: return state; &#125;&#125; Recommend/store/actionCreators.js12345678910111213141516171819202122232425262728293031323334353637// 导入常量import * as actionTypes from './constants';// 将JS对象转换成immutable对象import &#123; fromJS &#125; from 'immutable';// 导入网络请求import &#123; getBannerRequest, getRecommendListRequest &#125; from '../../../api/request';export const changeBannerList = (data) =&gt; (&#123; type: actionTypes.CHANGE_BANNER, data: fromJS(data)&#125;);export const changeRecommendList = (data) =&gt; (&#123; type: actionTypes.CHANGE_RECOMMEND_LIST, data: fromJS(data)&#125;);// 获取轮播图数据export const getBannerList = () =&gt; &#123; return (dispatch) =&gt; &#123; getBannerRequest().then(data =&gt; &#123; dispatch(changeBannerList(data.banners)); &#125;).catch(() =&gt; &#123; console.log("轮播图数据传输错误"); &#125;) &#125;&#125;;export const getRecommendList = () =&gt; &#123; return (dispatch) =&gt; &#123; getRecommendListRequest().then(data =&gt; &#123; dispatch(changeRecommendList(data.result)); &#125;).catch(() =&gt; &#123; console.log("推荐歌单数据传输错误"); &#125;); &#125;&#125;; Recommend/store/constants.js1234//constants.jsexport const CHANGE_BANNER = 'recommend/CHANGE_BANNER';export const CHANGE_RECOMMEND_LIST = 'recommend/RECOMMEND_LIST'; src/store/reducer.js123456789// 合并 reducer 函数import &#123; combineReducers &#125; from 'redux-immutable';// 导入分仓库的 reducerimport &#123; reducer as recommendReducer &#125; from '../application/Recommend/store/index';// 合并 reducer 函数为一个 objexport default combineReducers(&#123; recommend: recommendReducer,&#125;)]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（五）]]></title>
    <url>%2F2019%2F09%2F11%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲 Recommend 的 scroll 组件的开发。 打造 scroll 基础组件安装 better-scroll 插件是时候来做滑动组件啦。我们用插件 better-scroll 来做。 官网：https://ustbhuangyi.github.io/better-scroll/#/examples/index-view better-scroll 有两个版本： 12npm install better-scroll -S # install 1.xnpm install better-scroll@next -S # install 2.x，该版本带有所有插件的能力。 这里我们安装第二个版本： 1$ npm install better-scroll@next --save better-scroll 中文文档：https://github.com/ustbhuangyi/better-scroll/blob/master/README_zh-CN.md 使用参考资料：当 BetterScroll 遇见 Vue 业务 scroll 是基础组件，所以我们去 baseUI 种新建一个 scroll 文件夹及其 index.js 文件。 编写 scroll 插件： baseUI/scroll/index.js 导入文件： 12import React,&#123; useEffect, useState &#125; from 'react';import BScroll from "better-scroll"; better-scroll 的可配置参数： 123456789101112Scroll.propTypes = &#123; direction: PropTypes.oneOf(['vertical', 'horizental']),//滚动的方向 click: true,//是否支持点击 refresh: PropTypes.bool,//是否刷新 onScroll: PropTypes.func,//滑动触发的回调函数 pullUp: PropTypes.func,//上拉加载逻辑 pullDown: PropTypes.func,//下拉加载逻辑 pullUpLoading: PropTypes.bool,//是否显示上拉loading动画 pullDownLoading: PropTypes.bool,//是否显示下拉loading动画 bounceTop: PropTypes.bool,//是否支持向上吸顶 bounceBottom: PropTypes.bool//是否支持向下吸底&#125;; 好了，首先我们先来写整体组件的架构： 123456789101112import React,&#123; useEffect, useState, useEffect, useRef &#125; from 'react';import BScroll from "better-scroll";const Scroll = forwardRef((props, ref) =&gt; &#123; return ( &lt;ScrollContainer ref=&#123;scrollContaninerRef&#125;&gt; &#123;props.children&#125; &lt;/ScrollContainer&gt; );&#125;)export default Scroll; 这里我们要用 react Hooks，所以要引入 useEffect 和 useState。ScrollContainer 是样式组件，这里还没写，只是把结构放出来。 forwarRefforwardRef 即引用传递（Ref forwading）是一种通过父组件向子组件自动传递 引用ref 的技术。 当父组件需要控制其子组件的 DOM 的时候，如果我们仅仅在父组件中，在子组件的引用上，增加属性 ref，那么这个 ref 仅仅指向的是子组件，而不能知道子组件中的 DOM 节点。 而在 React16 中，我们可以通过 Forwarding refs 使得在父组件中可以得到子组件中的 DOM 节点。 Forwarding refs 中提供了一个 React.forwardRef 来创建组件，在 React.forwardRef 的方法中传递了参数 ref，通过这个 ref 可以指向具体的某一个 dom节点。具体的指向流程为： 父组件myRef——&gt;React.forwardRef中的实参——&gt;通过forwardRef方法创建的子组件中的ref——&gt;指向子组件中的某一个dom节点： 子组件： 123const Child=React.forwardRef((props,ref)=&gt;( &lt;input ref=&#123;ref&#125; /&gt;)); 父组件： 123456789101112class Father extends React.Component&#123; constructor(props)&#123; super(props); this.myRef=React.createRef(); &#125; componentDidMount()&#123; console.log(this.myRef.current); &#125; render()&#123; return &lt;Child ref=&#123;this.myRef&#125;/&gt; &#125;&#125; 通过上面的方法，父组件可以得到子组件种的 &lt;input /&gt;，而如果不用这种方法，得到的会是 child。 这种方法经常出现在高阶组件（HOC）中。 编写 scoll 核心逻辑代码使用 hooks首先写入 hooks 变量吧，在 scoll 组件内写入： 1234//better-scroll实例对象const [bScroll, setBScroll] = useState();//current指向初始化bs实例需要的DOM元素 const scrollContaninerRef = useRef(); 现在的组件是： 1234567891011121314151617import React,&#123; useEffect, useState, useEffect, useRef &#125; from 'react';import BScroll from "better-scroll";const Scroll = forwardRef((props, ref) =&gt; &#123; // better-scroll实例对象 const [bScroll, setBScroll] = useState(); // current指向初始化bs实例需要的DOM元素 const scrollContaninerRef = useRef(); return ( &lt;ScrollContainer ref=&#123;scrollContaninerRef&#125;&gt; &#123;props.children&#125; &lt;/ScrollContainer&gt; );&#125;)export default Scroll; 这里解释一下 useRef 好了，应该已经注意到 const scrollContaninerRef = useRef() 和 ref={scrollContaninerRef} 了。这里的 useRef 的作用是保存变量，它会保存 ScrollContainer 的 ref 到 scrollContaninerRef 中。 然后处理一下这个组件获取到的参数，在 scoll 组件内写入: 12const &#123; direction, click, refresh, pullUpLoading, pullDownLoading, bounceTop, bounceBottom &#125; = props;const &#123; pullUp, pullDown, onScroll &#125; = props; 我们通过结构赋值的方式拿到这些参数，虽然上面已经写过了，不过我再把可配置参数拿来对照着看吧。 123456789101112Scroll.propTypes = &#123; direction: PropTypes.oneOf(['vertical', 'horizental']),//滚动的方向 click: true,//是否支持点击 refresh: PropTypes.bool,//是否刷新 onScroll: PropTypes.func,//滑动触发的回调函数 pullUp: PropTypes.func,//上拉加载逻辑 pullDown: PropTypes.func,//下拉加载逻辑 pullUpLoading: PropTypes.bool,//是否显示上拉loading动画 pullDownLoading: PropTypes.bool,//是否显示下拉loading动画 bounceTop: PropTypes.bool,//是否支持向上吸顶 bounceBottom: PropTypes.bool//是否支持向下吸底&#125;; 创建 better-scroll接下来创建 better-scroll，在 scoll 组件内写入： 12345678910111213141516useEffect(() =&gt; &#123; const scroll = new BScroll(scrollContaninerRef.current, &#123; scrollX: direction === "horizental", scrollY: direction === "vertical", probeType: 3, click: click, bounce:&#123; top: bounceTop, bottom: bounceBottom &#125; &#125;); setBScroll(scroll); return () =&gt; &#123; setBScroll(null); &#125;&#125;, []); 定义的 BScroll 的更多内容请查阅文档：https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html，在选项基础中就可以看见属性的意义了。 这里用了 useEffect 的方法，值得注意的是在它的内部函数中有一个 return，这里是我前面没有提及的。现在说明一下： 而 useEffect 的第二个参数就是用来限制 useEffect 解绑的： 当 useEffect 不传入第二个参数的时候，每次状态发生变化，都会解绑； 当传空数组[]时，就是当组件将被销毁时才进行解绑； 传入值的话，就是值变动时才会解绑。 而挂载（mount）时，会执行一次非 return 的内容，而不执行 return 的函数，当 change 时，会执行第一次 return 的内容和第二次非 return 的内容。 重写渲染时刷新实例每次重新渲染都要刷新实例，防止无法滑动: 在 scoll 组件内写入： 12345useEffect(() =&gt; &#123; if(refresh &amp;&amp; bScroll)&#123; bScroll.refresh(); &#125;&#125;); 这里通过是否刷新 refresh 以及实例对象 bScroll 是否有内容来判断是否需要刷新。 给实例绑定 scroll 事件在 scoll 组件内写入： 123456789useEffect(() =&gt; &#123; if(!bScroll || !onScroll) return; bScroll.on('scroll', (scroll) =&gt; &#123; onScroll(scroll); &#125;) return () =&gt; &#123; bScroll.off('scroll'); &#125;&#125;, [onScroll, bScroll]); 当 bScroll 实例有值且同时存在滑动触发的回调函数 onScroll 时，执行 onScroll。 这里解释一下 scroll 的 on 和 off 好了，虽然在其文档的 方法/通用 中也可查。 on(type, fn, context) 参数： {String} type 事件名 {Function} fn 回调函数 {context} 函数执行的上下文环境，默认是 this 返回值：无 作用：监听当前实例上的自定义事件。如：scroll, scrollEnd, pullingUp, pullingDown等。 off(type, fn) 参数： {String} type 事件名 {Function} fn 回调函数 返回值：无 作用：移除自定义事件监听器。只会移除这个回调的监听器。 进行上拉到底的判断，调用上拉刷新的函数在 scoll 组件内写入： 123456789101112useEffect(() =&gt; &#123; if(!bScroll || !pullUp) return; bScroll.on('scrollEnd', () =&gt; &#123; //判断是否滑动到了底部 if(bScroll.y &lt;= bScroll.maxScrollY + 100)&#123; pullUp(); &#125; &#125;); return () =&gt; &#123; bScroll.off('scrollEnd'); &#125;&#125;, [pullUp, bScroll]); 同样的：当 bScroll 实例有值且同时存在上拉加载逻辑 pullUp 时，判断是否滑到了底部，若是，则执行 pullUp。 进行下拉的判断，调用下拉刷新的函数类似的，在 scoll 组件内写入： 123456789101112useEffect(() =&gt; &#123; if(!bScroll || !pullDown) return; bScroll.on('touchEnd', (pos) =&gt; &#123; //判断用户的下拉动作 if(pos.y &gt; 50) &#123; pullDown(); &#125; &#125;); return () =&gt; &#123; bScroll.off('touchEnd'); &#125;&#125;, [pullDown, bScroll]); 给外界暴露组件方法假设上层组件中： 1234//上层组件代码const scrollRef = useRef();...&lt;Scroll ref=&#123;scrollRef&#125;&gt;&lt;/Scroll&gt; 希望通过这种调用方法的方式刷新scroll组件： 1scrollRef.current.refresh(); 我们使用的方案是 React Hooks 中的 useImperativeHandle 提供的解决方案： 首先导入： 1import React, &#123; forwardRef, useState, useEffect, useRef, useImperativeHandle &#125; from "react"; 然后在 Scroll 组件里面写： 12345678910111213141516// 一般和forwardRef一起使用，ref已经在forWardRef中默认传入useImperativeHandle(ref, () =&gt; (&#123; //给外界暴露refresh方法 refresh() &#123; if(bScroll) &#123; bScroll.refresh(); bScroll.scrollTo(0, 0); &#125; &#125;, //给外界暴露getBScroll方法, 提供bs实例 getBScroll() &#123; if(bScroll) &#123; return bScroll; &#125; &#125;&#125;)); 默认赋值完了吗？不，我们还有一步，那就是在组件中默认赋值，这样我们这个组件才算完成： 默认赋值，在 scoll 组件外写入： 123456789101112Scroll.defaultProps = &#123; direction: "vertical", click: true, refresh: true, onScroll:null, pullUpLoading: false, pullDownLoading: false, pullUp: null, pullDown: null, bounceTop: true, bounceBottom: true&#125;; 这样就完成了默认赋值了。 类型检查上面已经把 scoll 组件写完了，但这个组件参数这么多，我们追求完美，不如给参数来个类型检查。 首先导入： 1import PropTypes from "prop-types"; 类型检查，在 scoll 组件外写入： 1234567891011Scroll.propTypes = &#123; direction: PropTypes.oneOf(['vertical', 'horizental']), refresh: PropTypes.bool, onScroll: PropTypes.func, pullUp: PropTypes.func, pullDown: PropTypes.func, pullUpLoading: PropTypes.bool, pullDownLoading: PropTypes.bool, bounceTop: PropTypes.bool,//是否支持向上吸顶 bounceBottom: PropTypes.bool//是否支持向上吸顶&#125;; 样式组件对了，我们这里使用了样式组件，代码如下，直接写在这个 index.js 中就行了： 导入： 1import styled from 'styled-components'; 在组件 scroll 外面写： 12345const ScrollContainer = styled.div` width: 100%; height: 100%; overflow: hidden;` 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import React, &#123; forwardRef, useState, useEffect, useRef, useImperativeHandle &#125; from "react";import PropTypes from "prop-types";import BScroll from "better-scroll";import styled from 'styled-components';const Scroll = forwardRef((props, ref) =&gt; &#123; // better-scroll实例对象 const [bScroll, setBScroll] = useState(); // current指向初始化bs实例需要的DOM元素 const scrollContaninerRef = useRef(); // 对象结构获取参数 const &#123; direction, click, refresh, pullUpLoading, pullDownLoading, bounceTop, bounceBottom &#125; = props; const &#123; pullUp, pullDown, onScroll &#125; = props; // 创建 better-scroll useEffect(() =&gt; &#123; const scroll = new BScroll(scrollContaninerRef.current, &#123; scrollX: direction === "horizental", // 当设置为 true 的时候，可以开启横向滚动。当设置 eventPassthrough 为 'horizontal' 的时候，该配置无效。 scrollY: direction === "vertical", // 当设置为 true 的时候，可以开启纵向滚动。当设置 eventPassthrough 为 'vertical' 的时候，该配置无效。 // 有时候我们需要知道滚动的位置。 // 当 probeType 为 1 的时候，会非实时（屏幕滑动超过一定时间后）派发scroll 事件； // 当 probeType 为 2 的时候，会在屏幕滑动的过程中实时的派发 scroll 事件； // 当 probeType 为 3 的时候，不仅在屏幕滑动的过程中，而且在 momentum 滚动动画运行过程中实时派发 scroll 事件。 // 如果没有设置该值，其默认值为 0，即不派发 scroll 事件。 probeType: 3, // better-scroll 默认会阻止浏览器的原生 click 事件。当设置为 true，better-scroll 会派发一个 click 事件，我们会给派发的 event 参数加一个私有属性 _constructed，值为 true。 click: click, // 当滚动超过边缘的时候会有一小段回弹动画。设置为 true 则开启动画。 // 这里使用的 变量 来控制 bounce: &#123; top: bounceTop, bottom: bounceBottom &#125; &#125;); setBScroll(scroll); return () =&gt; &#123; setBScroll(null); &#125; &#125;, []); // 每次渲染都刷新实例，防止无法滑动 useEffect(() =&gt; &#123; if (refresh &amp;&amp; bScroll) &#123; bScroll.refresh(); &#125; &#125;); // 给实例绑定scroll事件 useEffect(() =&gt; &#123; if (!bScroll || !onScroll) return; bScroll.on('scroll', (scroll) =&gt; &#123; onScroll(scroll); &#125;) return () =&gt; &#123; bScroll.off('scroll'); &#125; &#125;, [onScroll, bScroll]); // 进行上拉到底的判断，调用上拉刷新的函数 useEffect(() =&gt; &#123; if (!bScroll || !pullUp) return; bScroll.on('scrollEnd', () =&gt; &#123; //判断是否滑动到了底部 if (bScroll.y &lt;= bScroll.maxScrollY + 100) &#123; pullUp(); &#125; &#125;); return () =&gt; &#123; bScroll.off('scrollEnd'); &#125; &#125;, [pullUp, bScroll]); // 进行下拉到底的判断，调用下拉刷新的函数 useEffect(() =&gt; &#123; if (!bScroll || !pullDown) return; bScroll.on('touchEnd', (pos) =&gt; &#123; //判断用户的下拉动作 if (pos.y &gt; 50) &#123; pullDown(); &#125; &#125;); return () =&gt; &#123; bScroll.off('touchEnd'); &#125; &#125;, [pullDown, bScroll]); // 一般和forwardRef一起使用，ref已经在forWardRef中默认传入 useImperativeHandle(ref, () =&gt; (&#123; //给外界暴露refresh方法 refresh() &#123; if (bScroll) &#123; bScroll.refresh(); bScroll.scrollTo(0, 0); &#125; &#125;, //给外界暴露getBScroll方法, 提供bs实例 getBScroll() &#123; if (bScroll) &#123; return bScroll; &#125; &#125; &#125;)); return ( &lt;ScrollContainer ref=&#123;scrollContaninerRef&#125;&gt; &#123;props.children&#125; &lt;/ScrollContainer&gt; );&#125;)// 默认赋值Scroll.defaultProps = &#123; direction: "vertical", click: true, refresh: true, onScroll: null, pullUpLoading: false, pullDownLoading: false, pullUp: null, pullDown: null, bounceTop: true, bounceBottom: true&#125;;Scroll.propTypes = &#123; direction: PropTypes.oneOf(['vertical', 'horizental']), refresh: PropTypes.bool, onScroll: PropTypes.func, pullUp: PropTypes.func, pullDown: PropTypes.func, pullUpLoading: PropTypes.bool, pullDownLoading: PropTypes.bool, bounceTop: PropTypes.bool,//是否支持向上吸顶 bounceBottom: PropTypes.bool//是否支持向上吸顶&#125;;export default Scroll; 样式中使用到 Recommend 目录下的 index.js 中，导入 Scroll 组件： 1import Scroll from '../../baseUI/scroll'; 函数返回的JSX代码变化如下： 12345678&lt;Content&gt; &lt;Scroll className="list"&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerList&#125;&gt;&lt;/Slider&gt; &lt;List recommendList=&#123;recommendList&#125;&gt;&lt;/List&gt; &lt;/div&gt; &lt;/Scroll&gt;&lt;/Content&gt; 这里的 Content 是样式组件，因为只有一个，所以直接在当前目录下写好了： 123456789import styled from 'styled-components';export const Content = styled.div` position: fixed; top: 2.4rem; bottom: 0; width: 100%; max-width: 750px;` 这里解释一下，我们之前给了 &lt;Scroll&gt; 组件一个高度和宽度，都是相对于父容器 Content 的 100%。 我们滑动时，滑动的不是 &lt;Scroll&gt; 这个组件，而是它里面的内容，即 &lt;div&gt;。 然后看 Recommend 组件，这里我们写了个绝对定位的样式组件 Content，为什么呢？那是因为我们没有给我们的 Header 组件加绝对定位，如果不给 Recommend 加绝对定位的话，我们滑动时滑动的会是整个页面，但是给了 Recommend 一个绝对定位，它就脱离了文档流了，我们再给它一个宽和高，并设置 top 定好位置。这样由于 Recommend 脱离了文档流，有固定的宽高，所以我们才能看见滑动的功能。实际上设置 header 组件绝对定位也是可以的，这里就尝试一下这种方法吧。 现在打开页面，你就能体会到下拉吸顶、上拉吸底的感觉了。不过还是有一个问题，当你下拉的时候，中间会有一段空白，感觉比较突兀，因为我们图片背后的红色是通过 SliderContainer 中 .before 设置的，所以解决这个问题也很简单。 还是从遮罩入手吧，去 SliderContainer 中的 .before，它在轮播组件 slider 的 style.js 中，修改如下： 1234567.before&#123; position: absolute; top: -8rem; height: 10.666667rem; width: 100%; background: $&#123;style["theme-color"]&#125;;&#125; 如此修改即可，我们通过扩大了 .before 的高度，来实现填充下拉间隙的目的。 至此，我们的滑动组件就完成了。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（四）]]></title>
    <url>%2F2019%2F09%2F10%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲 Recommend 组件的开发，涉及UI方面的轮播图、列表，react 项目性能优化。 轮播组件开发Slider组件测试与使用在 src/application/Recommend/index.js 中，写入如下代码： 1234567891011121314151617import React from 'react';import Slider from '../../components/slider';function Recommend(props) &#123; const bannerList = [1, 2, 3, 4].map(item =&gt; &#123; return &#123; imageUrl: "http://p1.music.126.net/ZYLJ2oZn74yUz5x8NBGkVA==/109951164331219056.jpg" &#125; &#125;) return ( &lt;div&gt; &lt;Slider bannerList=&#123;bannerList&#125;&gt;&lt;/Slider&gt; &lt;/div&gt; )&#125;export default React.memo(Recommend); 我们在这里导入了我们的轮播图组件 Slider 并使用了它，当然这个组件我们还没写。 我们创建了一个数组 bannerList，用来模拟获取的数据，通过属性的方式传递给了 Slider 组件。 然后我们去 src/components 下新建一个 slilder 目录及其 index.js 文件夹： 12345678910111213141516171819import React from 'react';function Slider(props) &#123; const &#123; bannerList &#125; = props return ( &lt;div&gt; &#123; bannerList.map((slider, index) =&gt; &#123; return ( &lt;img key=&#123;index&#125; src=&#123;slider.imageUrl&#125; width="100%" height="100%" alt="推荐" /&gt; ); &#125;) &#125; &lt;/div&gt; )&#125;export default React.memo(Slider) 上面我们通过对象解构的方式获得了传递过来的数据 bannerList，然后使用这个数据创建了四个 img 标签，此时启动服务，在 Recommend 中可以看见四张图，如此我们的 Slider 组件可以正常使用。下面我们开始真正地编写一个轮播图组件吧。 使用 swiper 插件制作轮播图安装 swiper 并使用 react Hooks首先安装 swiper 插件： 1$ npm install swiper --save 在 index.js 中引入安装的 swiper 插件： 123import React,&#123; useEffect, useState &#125; from 'react';import "swiper/dist/css/swiper.css"import Swiper from 'swiper'; 这个项目是使用 react Hooks 进行开发的，所以我们同时引入了 react Hooks 开发必备的 useEffect 和 useState。 先利用 react Hooks 改写我们的组件： 12345678910111213141516171819202122232425import React, &#123; useEffect, useState &#125; from 'react';import "swiper/dist/css/swiper.css"import Swiper from 'swiper';function Slider(props) &#123; const [sliderSwiper, setSliderSwiper] = useState(null); const &#123; bannerList &#125; = props useEffect(() =&gt; &#123; &#125;) return ( &lt;div&gt; &#123; bannerList.map((slider, index) =&gt; &#123; return ( &lt;img key=&#123;index&#125; src=&#123;slider.imageUrl&#125; width="100%" height="100%" alt="推荐" /&gt; ); &#125;) &#125; &lt;/div&gt; )&#125;export default React.memo(Slider) 上面的代码就是通过 react Hooks 的方法改写的。 const [sliderSwiper, setSliderSwiper] = useState(null) 在 react Hooks 中用来定义变量。 上面我们定义了变量 sliderSwiper，我们会通过 setSliderSwiper 来修改变量 sliderSwiper，这里的 setSliderSwiper 不需要我们自己写方法，它被自动定义，类似setState。useState(null) 的参数是定义的 sliderSwiper 的初始值，这里我们把初始值设定为空。 其中 useEffect 是类似于 componentDidMount 和 componentDidUpdate 的函数，会在组件第一次挂载或更新时被调用，理所当然的，我们一般会在这里优化我们的渲染。下面我们会用到。 使用 swiperuseEffect 的第一个参数是一个方法。第二个参数是一个数组，数组中可以写入很多状态对应的变量。 当不写第二个参数时，每次状态发生变化，都会执行内部方法，包括 mount 和 update。 传入值时，当值发生变化时，我们才会执行内部方法。 当传空数组 [] 时，只会在组件 mount 时执行内部方法。 先看看 swiper 插件的使用结构，大家可以查阅 swiper 的 api：我们在 react Hooks 中这样写： 1234567891011121314151617181920212223242526const [sliderSwiper, setSliderSwiper] = useState(null);const &#123; bannerList &#125; = props;useEffect(() =&gt; &#123; if (bannerList.length &amp;&amp; !sliderSwiper) &#123; let sliderSwiper = new Swiper(".slider-container", &#123; loop: true, // 开启环路 autoplay: true, // 开启自动播放（默认3000ms） autoplayDisableOnInteraction: false, // 用户操作swiper后，是否停止autoplay。 pagination: &#123; el: '.swiper-pagination' &#125;, // 使用分页器导航 &#125;); setSliderSwiper(sliderSwiper); &#125;&#125;, [bannerList.length, sliderSwiper]); return ( &lt;div&gt; &lt;div className="slider-container"&gt; &lt;div className="swiper-wrapper"&gt; &lt;div className="swiper-slide"&gt;&#123;/* 图片展示 */&#125;&lt;/div&gt; &lt;/div&gt; &lt;div className="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 上面的 bannerList 是我们接收的图片数据，sliderSwiper 是我们定义的一个变量，通过 setSliderSwiper 对 sliderSwiper 进行修改，这正是 react Hooks 的语法。我们把 new Swiper 写在 useEffect 里面，给 useEffect 的第二个参数传入两个值：bannerList.length 和 sliderSwiper，除了挂载时（mount），只有当bannerList.length 或 sliderSwiper 变化（update）时才执行 useEffect 的内部方法。 所以，现在我们的 index.js 文件就变成了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; useEffect, useState &#125; from 'react';import "swiper/dist/css/swiper.css"import Swiper from 'swiper';import &#123; SliderContainer &#125; from './style';function Slider(props) &#123; const [sliderSwiper, setSliderSwiper] = useState(null); const &#123; bannerList &#125; = props; useEffect(() =&gt; &#123; if (bannerList.length &amp;&amp; !sliderSwiper) &#123; let sliderSwiper = new Swiper(".slider-container", &#123; loop: true, // 开启环路 autoplay: &#123; delay: 3000, // 自动播放（3000ms） stopOnLastSlide: false, // 图片在最后一张时回到第一张继续播放 disableOnInteraction: false, // 用户操作后不会停止自动播放 &#125;, pagination: &#123; el: '.swiper-pagination' &#125;, // 使用分页器导航 &#125;); setSliderSwiper(sliderSwiper); &#125; &#125;, [bannerList.length, sliderSwiper]); return ( &lt;SliderContainer&gt; &lt;div className="slider-container"&gt; &lt;div className="swiper-wrapper"&gt; &#123;/* 图片展示 */&#125; &#123; bannerList.map((slider, index) =&gt; &#123; return ( &lt;div key=&#123;index&#125; className="swiper-slide"&gt; &lt;img src=&#123;slider.imageUrl&#125; width="100%" height="100%" alt="推荐" /&gt; &lt;/div&gt; ); &#125;) &#125; &lt;/div&gt; &#123;/* 分页器。如果放置在swiper-container外面，需要自定义样式。 */&#125; &lt;div className="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/SliderContainer&gt; );&#125;export default React.memo(Slider) 我们现在就可以看到轮播图的效果了，不过现在轮播图的样式还有问题，所以我们调节一下轮播图的样式。 调节 swiper 样式因为整个 swiper 都放在了外面的样式组件 SliderContainer 中，所以去 style.js 中写样式吧： 首先导入文件： 12import styled from 'styled-components';import style from '../../assets/global-style'; 定义 SliderContainer 的整体样式： 12345export const SliderContainer = styled.div` position: relative; box-sizing: border-box; width: 100%;`; 定义 slider-container 的样式： 123456789export const SliderContainer = styled.div` .slider-container&#123; position: relative; width: 98%; overflow: hidden; margin:auto; border-radius: .16rem; &#125;`; overflow 很重要！！！ 定义分页器导航样式： 12345export const SliderContainer = styled.div` .swiper-pagination-bullet-active&#123; background: $&#123;style["theme-color"]&#125;; &#125;`; 就是换了一个颜色…… 然后发现图片背后还应该有个背景，外面在 SliderContainer 里面添加一个 div：&lt;div className=&quot;before&quot;&gt;&lt;/div&gt;，则现在的 SliderContainer 是： 12345678910111213141516171819&lt;SliderContainer&gt; &lt;div className="before"&gt;&lt;/div&gt; &lt;div className="slider-container"&gt; &lt;div className="swiper-wrapper"&gt; &#123; bannerList.map(slider =&gt; &#123; return ( &lt;div className="swiper-slide" key=&#123;slider.imageUrl&#125;&gt; &lt;div className="slider-nav"&gt; &lt;img src=&#123;slider.imageUrl&#125; width="100%" height="100%" alt="推荐" /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;) &#125; &lt;/div&gt; &lt;div className="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/SliderContainer&gt; 总结components/slider/index.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; useEffect, useState &#125; from 'react';import &#123; SliderContainer &#125; from './style';import "swiper/dist/css/swiper.css";import Swiper from "swiper";function Slider(props) &#123; const [sliderSwiper, setSliderSwiper] = useState(null); const &#123; bannerList &#125; = props; useEffect(() =&gt; &#123; if (bannerList.length &amp;&amp; !sliderSwiper) &#123; let sliderSwiper = new Swiper(".slider-container", &#123; loop: true, // 开启环路 autoplay: &#123; delay: 3000, // 自动播放（3000ms） stopOnLastSlide: false, // 图片在最后一张时回到第一张继续播放 disableOnInteraction: false, // 用户操作后不会停止自动播放 &#125;, pagination: &#123; el: '.swiper-pagination', type: 'bullets', &#125;, // 使用分页器导航 &#125;); setSliderSwiper(sliderSwiper); &#125; &#125;, [bannerList.length, sliderSwiper]); return ( &lt;SliderContainer&gt; &lt;div className="before"&gt;&lt;/div&gt; &lt;div className="slider-container"&gt; &lt;div className="swiper-wrapper"&gt; &#123;/* 图片展示 */&#125; &#123; bannerList.map((slider, index) =&gt; &#123; return ( &lt;div key=&#123;index&#125; className="swiper-slide"&gt; &lt;img src=&#123;slider.imageUrl&#125; width="100%" height="100%" alt="推荐" /&gt; &lt;/div&gt; ); &#125;) &#125; &lt;/div&gt; &#123;/* 分页器。如果放置在swiper-container外面，需要自定义样式。 */&#125; &lt;div className="swiper-pagination"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/SliderContainer&gt; );&#125;export default React.memo(Slider) components/slider/style.js： 123456789101112131415161718192021222324252627import styled from 'styled-components';import style from '../../assets/global-style';export const SliderContainer = styled.div` position: relative; box-sizing: border-box; width: 100%; .before&#123; position: absolute; top: 0; height: 60%; width: 100%; background: $&#123;style["theme-color"]&#125;; &#125; .slider-container&#123; position: relative; width: 98%; overflow: hidden; margin:auto; border-radius: .16rem; &#125; .swiper-pagination-bullet-active&#123; background: $&#123;style["theme-color"]&#125;; &#125;`; 推荐列表的开发RecommendList 组件测试与使用在 recommend 组件中，导入 List 组件： 1import List from '../../components/list'; 使用 List 组件： 123456return ( &lt;div&gt; &lt;Slider bannerList=&#123;bannerList&#125;&gt;&lt;/Slider&gt; &lt;List recommendList=&#123;recommendList&#125;&gt;&lt;/List&gt; &lt;/div&gt; ) 然后我们去 src/components 下新建一个 list 文件夹及其 index.js 文件夹： 123456789101112131415161718import React from 'react';function RecommendList(props) &#123; const &#123; recommendList &#125; = props return ( &lt;div&gt; &#123; recommendList.map((item, index) =&gt; &#123; return ( &lt;img key=&#123;index&#125; src=&#123;item.picUrl&#125; alt=&#123;item.name&#125; /&gt; ) &#125;) &#125; &lt;/div&gt; )&#125;export default React.memo(RecommendList) 如你所见，因为这里没有涉及到业务，所以使用的是无状态组件。 现在启动服务就可以看见我们获取到的数据了。 RecommendList 组件样式布局既然已经可以拿到数据了，就开始做样式和布局吧。同样的在当前目录下创建 style.js，在里面写样式组件并在 index.js 中导入： 12345import &#123; ListWrapper, List, ListItem,&#125; from './style'; 使用： 1234567891011121314151617&lt;ListWrapper&gt; &lt;ListTitle&gt; &lt;div className='title'&gt;推荐歌单&lt;/div&gt; &lt;div className='tag'&gt;歌单广场&lt;/div&gt; &lt;/ListTitle&gt; &lt;List&gt; &#123; recommendList.map((item, index) =&gt; &#123; return ( &lt;ListItem&gt; &lt;img key=&#123;index&#125; src=&#123;item.picUrl&#125; alt=&#123;item.name&#125; /&gt; &lt;/ListItem&gt; ) &#125;) &#125; &lt;/List&gt;&lt;/ListWrapper&gt; 上面我分了三个样式组件，首先是整体的 ListWraper，头部 ListTitle，然后是 List，它包含众多的 ListItem，每一个 ListItem 都是一份数据。 对此的样式 style.js 是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import styled from 'styled-components';import style from '../../assets/global-style';export const ListWrapper = styled.div` position: relative; width: 100%;`export const ListTitle = styled.div` overflow: hidden; line-height: 1.066667rem; display: flex; flex-direction: row; justify-content: space-between; align-items: center; .title &#123; font-size: .373333rem; font-weight: 700; padding-left: .16rem; &#125; .tag &#123; height: .266667rem; font-size: .266667rem; font-weight: 600; padding: .053333rem .16rem; margin-right: .16rem; line-height: .266667rem; color: #444; border: .026667rem solid rgb(211, 210, 210); border-radius: .213333rem; &#125;`export const List = styled.div` display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between;`export const ListItem = styled.div` box-sizing: border-box; flex: 33.33%; padding: 0 .16rem .16rem .16rem; img &#123; width: 100%; &#125;` 然后在做 ListItem 的布局样式： index.js： 123456789101112&lt;ListItem key=&#123;item.id&#125;&gt; &lt;div className="img_wrapper"&gt; &lt;div className="decorate"&gt;&lt;/div&gt; &#123;/* 加此参数可以减小请求的图片资源大小 */&#125; &lt;img src=&#123;item.picUrl + "?param=300x300"&#125; width="100%" height="100%" alt="music" /&gt; &lt;div className="play_count"&gt; &lt;i className="iconfont play"&gt;&amp;#xe885;&lt;/i&gt; &lt;span className="count"&gt;&#123;item.playCount&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className="desc"&gt;&#123;item.name&#125;&lt;/div&gt;&lt;/ListItem&gt; styles.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445export const ListItem = styled.div` position: relative; width: 32%; .img_wrapper&#123; .decorate &#123; position: absolute; top: 0; width: 100%; height: .933333rem; border-radius: .08rem; background: linear-gradient(hsla(0,0%,43%,.4),hsla(0,0%,100%,0)); &#125; position: relative; height: 0; padding-bottom: 100%; .play_count &#123; position: absolute; right: .053333rem; top: .053333rem; font-size: .32rem; line-height: .4rem; color: $&#123;style["font-color-light"]&#125;; .play&#123; font-size: .426667rem; vertical-align: top; &#125; &#125; img &#123; position: absolute; width: 100%; height: 100%; border-radius: .08rem; &#125; &#125; .desc &#123; overflow: hidden; margin-top: .053333rem; padding: 0 .053333rem; height: 1.333333rem; text-align: left; font-size: .32rem; line-height: 1.4; color: $&#123;style["font-color-desc"]&#125;; &#125;` 封装工具函数如今已经可以看到样式了，但是有一个小细节：听过人数现在不好看，最好能用带单位的方式呈现，所以我们要封装一个用来计算的函数，我们在 src/api 下面新建一个 utils.js 文件，里面放这个工具函数： 12345678910export const getCount = (count) =&gt; &#123; if (count &lt; 0) return; if (count &lt; 10000) &#123; return count; &#125; else if (Math.floor(count / 10000) &lt; 10000) &#123; return Math.floor(count / 1000) / 10 + "万"; &#125; else &#123; return Math.floor(count / 10000000) / 10 + "亿"; &#125;&#125; 然后在 index.js 中引用它： 1import &#123; getCount &#125; from "../../api/utils"; 使用它进行计算： 1&lt;span className="count"&gt;&#123;getCount(item.playCount)&#125;&lt;/span&gt; 小细节在 ListItem 中 img 标签的上方，有个这个：&lt;div className=&quot;decorate&quot;&gt;&lt;/div&gt; 对应的 style.js 样式： 12345678.decorate &#123; position: absolute; top: 0; width: 100%; height: 35px; border-radius: 3px; background: linear-gradient(hsla(0,0%,43%,.4),hsla(0,0%,100%,0));&#125; 三元大佬原文：它的作用就是给给图片上的图标和文字提供一个遮罩，因为在字体颜色是白色，在面对白色图片背景的时候，文字会看不清或者看不到，因此提供一个阴影来衬托出文字，这个细节很容易被忽略, 希望大家也能注意一下。 这个细节很到位啊，这里就提升了用户体验，学到了。 总结components/list/index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142import React from 'react';import &#123; ListWrapper, List, ListTitle, ListItem,&#125; from './style';import &#123; getCount &#125; from "../../api/utils";function RecommendList(props) &#123; const &#123; recommendList &#125; = props return ( &lt;ListWrapper&gt; &lt;ListTitle&gt; &lt;div className='title'&gt;推荐歌单&lt;/div&gt; &lt;div className='tag'&gt;歌单广场&lt;/div&gt; &lt;/ListTitle&gt; &lt;List&gt; &#123; recommendList.map((item, index) =&gt; &#123; return ( &lt;ListItem key=&#123;item.id&#125;&gt; &lt;div className="img_wrapper"&gt; &lt;div className="decorate"&gt;&lt;/div&gt; &#123;/* 加此参数可以减小请求的图片资源大小 */&#125; &lt;img src=&#123;item.picUrl + "?param=300x300"&#125; width="100%" height="100%" alt="music" /&gt; &lt;div className="play_count"&gt; &lt;i className="iconfont play"&gt;&amp;#xe885;&lt;/i&gt; &lt;span className="count"&gt;&#123;getCount(item.playCount)&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className="desc"&gt;&#123;item.name&#125;&lt;/div&gt; &lt;/ListItem&gt; ) &#125;) &#125; &lt;/List&gt; &lt;/ListWrapper&gt; )&#125;export default React.memo(RecommendList) components/list/style.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import styled from 'styled-components';import style from '../../assets/global-style';export const ListWrapper = styled.div` position: relative; width: 100%;`export const ListTitle = styled.div` overflow: hidden; line-height: 1.066667rem; display: flex; flex-direction: row; justify-content: space-between; align-items: center; .title &#123; font-size: .373333rem; font-weight: 700; padding-left: .16rem; &#125; .tag &#123; height: .266667rem; font-size: .266667rem; font-weight: 600; padding: .053333rem .16rem; margin-right: .16rem; line-height: .266667rem; color: #444; border: .026667rem solid rgb(211, 210, 210); border-radius: .213333rem; &#125;`export const List = styled.div` display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-around;`export const ListItem = styled.div` position: relative; width: 32%; .img_wrapper&#123; .decorate &#123; position: absolute; top: 0; width: 100%; height: .933333rem; border-radius: .08rem; background: linear-gradient(hsla(0,0%,43%,.4),hsla(0,0%,100%,0)); &#125; position: relative; height: 0; padding-bottom: 100%; .play_count &#123; position: absolute; right: .053333rem; top: .053333rem; font-size: .32rem; line-height: .4rem; color: $&#123;style["font-color-light"]&#125;; .play&#123; font-size: .426667rem; vertical-align: top; &#125; &#125; img &#123; position: absolute; width: 100%; height: 100%; border-radius: .08rem; &#125; &#125; .desc &#123; overflow: hidden; margin-top: .053333rem; padding: 0 .053333rem; height: 1.333333rem; text-align: left; font-size: .32rem; line-height: 1.4; color: $&#123;style["font-color-desc"]&#125;; &#125;`]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（三）]]></title>
    <url>%2F2019%2F09%2F09%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲 redux 的使用，初步搭建 store 的结构。 redux准备安装对应的依赖1$ npm install redux redux-thunk redux-immutable react-redux immutable --save redux、react-redux 它们自不必说，是使用 redux 必备的。 reudx-thunk 是中间件，类似的还有 saga，这里我们使用的是 thunk。 immutable 是 Facebook 开发一个 持久化数据结构，它是一经创建变不可修改的数据，普遍运用于 redux 中。 创建总仓库在 src 的 store 目录下，创建 index.js 和 reducer.js，我们写给 reducer.js 添加内容： 12345import &#123; combineReducers &#125; from 'redux-immutable';export default combineReducers(&#123; &#125;) 应当注意到我们导入了 redux-immutable 的方法 combineReducers，combineReducers 是一个辅助函数，这一小节的标题是：创建总仓库。所以现在创建的这个仓库并不是用来存放某些具体的数据的，而是用来整合其他仓库的 reducer 的数据的，而辅助函数 combineReducers 就用来帮我们完成这件事。 combineReducers 辅助函数的作用是，把多个不同 reducer 函数（功能组件中的 reducer）作为 value，合并成一个最终的 reducer 函数（我们现在的这个reducer）的 object，然后就可以对我们现在这个 reducer 调用 createStore。 在后面会体现它的作用。 然后是 index.js 文件： 123456789import &#123; createStore, compose, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducer';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk))) 应当注意到，这里使用了增强函数，在启用谷歌调试工具 redux 的基础上使用了中间件 thunk。 在项目中使用 store我们去 App.js 中做一些修改： 12345678910111213141516171819202122import React from 'react';import &#123; IconStyle &#125; from './assets/iconfont/iconfont';import &#123; GlobalStyle &#125; from './style';import &#123; HashRouter &#125; from 'react-router-dom';import &#123; renderRoutes &#125; from 'react-router-config';import routes from './routes';import &#123; Provider &#125; from 'react-redux';import store from './store/index';function App() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;HashRouter&gt; &lt;GlobalStyle&gt;&lt;/GlobalStyle&gt; &lt;IconStyle&gt;&lt;/IconStyle&gt; &#123;renderRoutes(routes)&#125; &lt;/HashRouter&gt; &lt;/Provider&gt; );&#125;export default App; 我们导入我们刚刚创建的仓库 store，然后使用 react-redux 的 Provider 方法，让我们的仓库能被所有被 &lt;Provider store={store}&gt;&lt;/Provider&gt; 的组件使用。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（二）.md]]></title>
    <url>%2F2019%2F09%2F09%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲 Home 组件的开发与 rem 布局 全局样式准备三元大佬用的是 px 布局，这里我准备改一下，用 rem 布局。 使用 flexible.js安装： 1$ npm i lib-flexible --save 使用： 在 src 的 App.js 中导入 flexible： 1import 'lib-flexible' 书写全局样式我们先去 assets 目录下新建 global-style.js 文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这里定义的全局的通用属性// 扩大可点击区域const extendClick = () =&gt; &#123; return` position: relative; &amp;:before &#123; content: ''; position: absolute; top: -.266667rem; bottom: -.266667rem; left: -.266667rem; right: -.266667rem; &#125; `&#125;// 一行文字溢出部分用 …… 代替const noWrap = () =&gt; &#123; return` text-overflow: ellipsis; overflow: hidden; white-space: nowrap; `&#125;export default &#123; 'theme-color': '#d44439', // 主题颜色——网易云红 'theme-color-shadow': 'rgba(212, 68, 57, .5)', // 主题颜色——暗色 'font-color-light': '#f1f1f1', // 字体颜色——高亮灰白色 'font-color-desc': '#2E3030', // 字体颜色——黑灰色 'font-color-desc-v2': '#bba8a8', // 字体颜色——带红色的深灰色 'font-size-ss': '10px', // 字体大小——极小 'font-size-s': '12px', // 字体大小——小 'font-size-m': '14px', // 字体大小——正常 'font-size-l': '16px', // 字体大小——大 'font-size-ll': '18px', // 字体大小——极大 'border-color': '#e4e4e4', // 边框颜色——白灰色 'background-color': '#f2f3f4', // 背景颜色——银灰色 'background-color-shadow': 'rgba(0, 0, 0, 0.3)', // 背景颜色——深灰黑色 'hightlight-background-color': '#fff', // 背景颜色——白色 extendClick, noWrap&#125; 上面注释掉的是三元大佬的代码，我用的 rem 重写了一份，这里我假设设计稿是 750px，而我使用了 flexible.js 来做适配，因为 flexible.js 是把设备划分为 10份，所有我这边 1rem 为 75px。可以使用 cssrem 这个插件来帮助我们进行计算，只要记得把 Cssrem: Root Font Size 的大小设置为 75 就好了。具体的原因请自行百度。：） 值得注意的是我们这里的字体大小并没有使用 rem，依然使用的是 px。但是我们使用的图标需要使用 rem，这里可能不会被注意到，因为我们不希望字体随屏幕变化，但是图标我们希望它是自适应的。上面没有用到图标，下面这一小节就展示了图标用 rem 而字体用 px。 顶部栏开发书写顶部栏样式我们使用 styled-components 来做组件： 123456789101112131415161718import styled from 'styled-components';import style from '../../assets/global-style';export const Top = styled.div` display: flex; flex-direction: row; justify-content: space-between; padding: 5px 10px; background: $&#123;style["theme-color"]&#125;; &amp;&gt;span &#123; line-height: 1.066667rem; color: #f1f1f1; font-size: 20px; &amp;.iconfont &#123; font-size: .666667rem; &#125; &#125;` 你应该注意到了，这里我们导入了全局样式 global-style，并使用里面预先设定好的颜色：theme-color，这正是 styled-components 的优点，它和 less 一样，允许我们使用变量，而这里我们是用 js 语法写的，所以变量的使用方法是：${style[&quot;theme-color&quot;]}，这里是对象解构的写法。 使用样式组件123456789101112131415161718192021//src/appliction/Home/index.jsimport React from 'react';import &#123; renderRoutes &#125; from "react-router-config";import &#123; Top &#125; from './style';function Home(props) &#123; const &#123; route &#125; = props; return ( &lt;div&gt; &lt;Top&gt; &lt;span className="iconfont menu"&gt;&amp;#xe65c;&lt;/span&gt; &lt;span className="title"&gt;WebApp&lt;/span&gt; &lt;span className="iconfont search"&gt;&amp;#xe62b;&lt;/span&gt; &lt;/Top&gt; &#123; renderRoutes(route.routes) &#125; &lt;/div&gt; )&#125;export default React.memo(Home); 现在就启动服务，就可以看见效果了。 Tab栏开发书写Tab栏样式同样的，我们使用 styled-components 来写样式组件。 我们先写整体的包含快 Tab： 12345678export const Tab = styled.div` height: 1.066667rem; display: flex; flex-direction: row; justify-content: space-between; background-color: $&#123;style['theme-color']&#125;;`; 现在我们定义了 Tag 的高，因为它里面有三个子元素，所有我们使用 flex 布局，给 Tag 一个背景颜色。 之后写里面的三个小组件的样式： 1234567export const TabItem = styled.div` height: 100%; display: flex; flex-direction: row; justify-content: center; align-items: center;` 现在的 Tag 组件： 12345&lt;Tab&gt; &lt;TabItem&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;/TabItem&gt; &lt;TabItem&gt;&lt;span&gt;歌手&lt;/span&gt;&lt;/TabItem&gt; &lt;TabItem&gt;&lt;span&gt;排行榜&lt;/span&gt;&lt;/TabItem&gt;&lt;/Tab&gt; 运用路由： 导入 123```jsimport &#123; NavLink &#125; from &apos;react-router-dom&apos;;//利用NavLink组件进行路由跳转 现在的 Tag 组件： 12345&lt;Tab&gt; &lt;NavLink to="/recommend" activeClassName="selected"&gt;&lt;TabItem&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;/TabItem&gt;&lt;/NavLink&gt; &lt;NavLink to="/singers" activeClassName="selected"&gt;&lt;TabItem&gt;&lt;span&gt;歌手&lt;/span&gt;&lt;/TabItem&gt;&lt;/NavLink&gt; &lt;NavLink to="/rank" activeClassName="selected"&gt;&lt;TabItem&gt;&lt;span&gt;排行榜&lt;/span&gt;&lt;/TabItem&gt;&lt;/NavLink&gt;&lt;/Tab&gt; 更新 Tab 样式： 使用 &lt;NavLink&gt;&lt;/NavLink&gt; 组件，会变成 a 标签，所有我们修改后的样式是： 12345678910111213141516171819202122export const Tab = styled.div` height: 1.066667rem; display: flex; flex-direction: row; justify-content: space-between; background-color: $&#123;style['theme-color']&#125;; a &#123; flex: 1; padding: .053333rem 0; font-size: .373333rem; color: #e4e4e4; &amp;.selected &#123; span &#123; padding: .08rem 0; font-weight: 700; color: #f1f1f1; border-bottom: .053333rem solid #f1f1f1; &#125; &#125; &#125;`; 注意到 a 同级的样式 selected，这个样式使用了 activeClassName，这个方法会在处于当前路由时，自动添加里面写的样式，所以上面我们给三个 &lt;NavLink&gt;&lt;/NavLink&gt; 都写了 activeClassName=&quot;selected&quot;，这样当我们选中哪一个路由时，哪一个路由就有了 selected 的样式。 还应当这样 selected 样式是添加到 a 标签上的，所以我们在 a 的样式中使用的是 &amp;，表示同级的关系。 现在应当可以展示结果，并通过点击实现路由的切换效果了。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的 Git 命令.md]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这里主要介绍的是 Git 的常用命令 初始化 git1$ git init 项目关联1$ git remote add origin 项目对应的SSH 查看本地分支1$ git branch 删除本地分支1$ git branch -d [本地分支名称] 查看远程分支1$ git branch -r 删除远程分支1$ git push origin --delete [远程分支名称] 查看所有分支1$ git branch -a 查看远程仓库1$ git remote -v 克隆远程仓库1$ git clone 远程的地址 查看当前本地仓库的状态1$ git status 把当前所作的更改提交到本地仓库1$ git add . 或者 1$ git add [name] 提交仓库里面的内容1$ git commit -m "注释" 注释是必须要写的 同步到 Github1$ git push origin master 这里我是同步到的 master 分支。 回退1$ git reset --hard HEAD^ 值得注意的是，这个命令回退的是最后一次提交的，如果可以的话，最好使用回退到指定版本。 回退到指定版本只需讲 HEAD^ 更改为对应的提交记录号就可以了。 创建并切换到当前分支1$ git checkout -b 分支名称 查看提交记录1$ git log 查看完成后可以使用 :q 退出。 将本地的新分支推送到远程1$ git push origin 远程分支名:本地分支名 两个（远程、本地）分支名要相同。 合并本地分支如果现在是在 分支2 上面，且 分支2 上有新内容，要把新内容合并到旧的 分支1，先切换回 分支1，然后执行下面的语句： 1$ git merge 分支2 现在就把 分支2 的内容合并到了 分支1，然后推送 分支1 就可以了： 1$ git push origin 分支1 总结：多开分支创建 SSH KEY1$ ssh-keygen -t rsa -C "2533566560@qq.com" 这里填注册 GitHub 的邮箱。 去 GitHub 中的 settings 的 SSH and GPG keys，点击 add SSH Key，把 C:\Users\Administrator\.ssh\id_rsa.pub 里面的内容粘贴到 key 里面，title 随便写。 验证是否成功： 1$ ssh -T git@github.com 出现： 1Hi wispyoureyes! You've successfully authenticated, but GitHub does not provide shell access. 说明成功，设置 username 和 email： 12$ git config --global user.name "name"//你的GitHub登陆名$ git config --global user.email "123@126.com"//你的GitHub注册邮箱]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的 Hexo 命令.md]]></title>
    <url>%2F2019%2F09%2F09%2F%E5%B8%B8%E7%94%A8Hexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这里主要介绍的是 Hexo 的常用命令 清除1$ hexo clean 生成1$ hexo g 部署1$ hexo s 提交1$ hexo d 创建新文章1$ hexo new post 新文章名称]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿网易云做的 WebApp（一）.md]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E5%81%9A%E7%9A%84%20WebApp%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[跟着三元大佬做的一款网易云音乐的 WebApp（三元大佬电子书链接：https://sanyuan0704.github.io/react-cloud-music/） 主要技术栈：react hooks + redux + immutable.js + rem 这一章主要讲全局样式与路由配置 src 目录改造1234567891011├─api // 网路请求代码、工具类函数和相关配置├─application // 项目核心功能├─assets // 字体配置及全局样式├─baseUI // 基础UI轮子├─components // 可复用的UI组件├─routes // 路由配置文件└─store // redux相关文件 App.js // 根组件 index.js // 入口文件 serviceWorker.js // PWA离线应用配置 style.js // 默认样式 项目依赖安装定义样式的插件 styled-components 这个项目利用的是 css in js，所以我们先安装：styled-components 1$ npm install styled-components --save 它的作用就是让我们能够使用 js 来书写 css 样式。如果是用 vsCode 写这个项目的话，可以搜索 vscode-styled-components 这个插件来辅助我们书写代码。 安装路由插件插件 react-router react-router-dom react-router-config 1$ npm install react-router react-router-dom react-router-config --save 我们利用 react-router-dom 来写路由，而 react-router-config 是静态路由配置的小助手，我们用它来配置我们的静态路由。 这个项目使用的路由是 HashRouter。 全局样式书写全局样式在 src 目录的 style.js 里面写入下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import &#123; createGlobalStyle &#125; from 'styled-components';export const GlobalStyle = createGlobalStyle` html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125; /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125; body &#123; line-height: 1; &#125; html, body&#123; background: #f2f3f4;; &#125; ol, ul &#123; list-style: none; &#125; blockquote, q &#123; quotes: none; &#125; blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; a&#123; text-decoration: none; color: #fff; &#125;` 这段代码是用来定义全局样式的。所有 styled-components 的代码都需要通过引入 styled-components 插件后，通过 export const GlobalStyle = createGlobalStyle 的方式使用，在这里面我们可以书写 CSS 代码，代码的格式类似于 Less。 导入全局样式然后在 App.js 中使用它： 123456789101112131415import React from 'react';import &#123; IconStyle &#125; from './assets/iconfont/iconfont';import &#123; GlobalStyle &#125; from './style';function App() &#123; return ( &lt;div className="App"&gt; &lt;GlobalStyle&gt;&lt;/GlobalStyle&gt; &lt;IconStyle&gt;&lt;/IconStyle&gt; &lt;div&gt;组件&lt;/div&gt; &lt;/div&gt; );&#125;export default App; 这里的使用方法就是这样，只要把我们的样式组件放在需要该样式的组件的上方就行了。这里的 IconStyle 是我们下面要导入的图标组件。 导入图标修改图标文件图标文件可以在我的项目中拿。 在 src 的 assets 目录下，创建一个 iconfont 文件夹，里面放我们我们的图标文件，这里的图标来源于阿里图标库，我个人也很喜欢它，个人认为它比起国外的 icomoon 舒服很多。 图标这里没什么好说的，唯一的就是把 iconfont.css 文件改成 iconfont.js 文件，当然，里面的内容也要修改： 在 iconfont.js 里面引入 styled-components，利用它来把我们的 css 转化成 js，我们保留 @font-face 和 .iconfont 的内容，其他的删掉： 1234567891011121314151617181920import &#123;createGlobalStyle&#125; from 'styled-components';export const IconStyle = createGlobalStyle`@font-face &#123;font-family: "iconfont"; src: url('iconfont.eot?t=1565320061289'); /* IE9 */ src: url('iconfont.eot?t=1565320061289#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,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') format('woff2'), url('iconfont.woff?t=1565320061289') format('woff'), url('iconfont.ttf?t=1565320061289') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1565320061289#iconfont') format('svg'); /* iOS 4.1- */&#125;.iconfont &#123; font-family: "iconfont" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;` 导入图标文件然后在 App.js 中使用它： 123456789101112131415import React from 'react';import &#123; IconStyle &#125; from './assets/iconfont/iconfont';import &#123; GlobalStyle &#125; from './style';function App() &#123; return ( &lt;div className="App"&gt; &lt;GlobalStyle&gt;&lt;/GlobalStyle&gt; &lt;IconStyle&gt;&lt;/IconStyle&gt; &lt;div&gt;组件&lt;/div&gt; &lt;/div&gt; );&#125;export default App; 上面其实已经导入了，这里只是再强调一下使用方法。 路由配置书写路由文件在 src 目录的 routes 文件夹中新建 index.js 文件，利用 react-router-config 来对路由进行配置。 我们在文件中引入： 123456import React from 'react';import &#123; Redirect &#125; from 'react-router-dom';import Home from '../application/Home';import Recommend from '../application/Recommend';import Singers from '../application/Singers';import Rank from '../application/Rank'; react 自不必说，是 JSX 语法必备的，而 react-router-dom 的 Redirect 是用来做重定向的插件。 而下面的 Home、Recommend、Singers、Rank 是四个组件，其中 Home 对应的是公共组件，其他三个是具体的功能组件：Recommend 是推荐组件，Singers 是歌手列表组件，Rank 是排行榜组件。 下面写路由： 123456789101112131415161718192021222324252627export default [ &#123; path: '/', component: Home, routes: [ &#123; path: '/', exact: true, render: () =&gt; ( &lt;Redirect to=&#123;'/recommend'&#125; /&gt; ) &#125;, &#123; path: '/recommend', component: Recommend &#125;, &#123; path: '/singers', component: Singers &#125;, &#123; path: '/rank', component: Rank &#125;, ] &#125;] 第一个路由指定 &#39;/&#39; 是进入的主界面，同时二级路由显示的是 Recommend 组件也就是推荐组件的内容。exact 是精确匹配的意思，当通过 &#39;/&#39; 进入主界面的时候，会进行重定向操作。 导入路由文件在 App.js 文件夹导入路由文件： 123import routes from './routes';import &#123; HashRouter &#125; from 'react-router-dom';import &#123; renderRoutes &#125; from 'react-router-config'; 第一个导入的就是我们写的路由配置文件，下面导入的是 react-router-dom，我们只用的 HashRouter 路由组件，然后导入 react-router-config，这个就是用来把我们写的路由配置文件 routes 中的内容转化成 Route 标签的。 123456789101112131415161718import React from 'react';import &#123; IconStyle &#125; from './assets/iconfont/iconfont';import &#123; GlobalStyle &#125; from './style';import routes from './routes';import &#123; HashRouter &#125; from 'react-router-dom';import &#123; renderRoutes &#125; from 'react-router-config'; // renderRoutes 读取路由配置转化为 Route 标签function App() &#123; return ( &lt;HashRouter&gt; &lt;GlobalStyle&gt;&lt;/GlobalStyle&gt; &lt;IconStyle&gt;&lt;/IconStyle&gt; &#123; renderRoutes(routes) &#125; &lt;/HashRouter&gt; );&#125;export default App; 编写组件以测试效果在 application 文件夹下新建 Home 文件夹，然后新建 index.js 文件： 123456789import React from 'react';function Home(props) &#123; return ( &lt;div&gt;Home&lt;/div&gt; )&#125;export default React.memo(Home); 这里，我们只写了村函数组件，上面的 React.memo 是用来控制组件渲染的，类似于 PureComponent，使用 React.memo 时，组件只会在它的 props 发生变化时重新渲染。它与 PureComponent 不同的是 PureComponent 要依靠 class 才能使用，而 React.memo() 可以和 functional component 一起使用。 类似的编写 Recommend、Singers、Rank 组件。 如果现在启动项目，我们可以看见 Home 的字样，但是我们的 Home 下面应该还有二级路由的 Recommend，而 renderRoutes 这个方法只渲染一层路由，所有我们需要在 Home 组件下再次调用一次 renderRoutes 来渲染第二层界面： 123456789101112131415import React from 'react';import &#123; renderRoutes &#125; from 'react-router-config'function Home(props) &#123; const &#123; route &#125; = props; return ( &lt;div&gt; &lt;div&gt;Home&lt;/div&gt; &#123;renderRoutes(route.routes)&#125; &lt;/div&gt; )&#125;export default React.memo(Home); 现在就正常显示了。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>CloudMusic WebApp</tag>
        <tag>rem</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习清单（备忘用）.md]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[学习清单（备忘用） js 的原始/对象类型如何在函数中传递有状态组件/无状态组件BST（广度搜索与深度搜索）promise（race与all，执行顺序【Even Loog】）深拷贝与浅拷贝OSI七层与HTTPS四层Url到页面渲染链表同源协议（跨域）排序算法大小堆归并与快排HTTP 与 HTTPS相对定位与绝对定位rem 与 vw/vh 各自特点与异同前端跨域的解决方案闭包this 的指向（方法调用与函数调用）JS中的事件冒泡与事件捕获JS中的字符串转化为整数JS中的小数加减法call、bind、applynew 和 create.Object()缓存浮动原型与原型链回流，重绘防抖，节流BFCflexsass 与 less标记清除与引用计数浏览器优化（阻塞渲染）js 基础类型两种盒模型性能优化，图片懒加载与图片预加载]]></content>
  </entry>
  <entry>
    <title><![CDATA[找工作（备忘用）.md]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[找工作（备忘用） 8.【度小满——内推】招聘岗位：技术、产品’、数据、用户、管理支持类网申地址： http://hturl.cc/24u82 9.【威睿】招聘岗位：软件开发、测试开发、销售代表、售后技术咨询、售前技术工程师网申地址：http://hturl.cc/driof 10.【同花顺】招聘岗位：研发、金融研究、设计、产品、运营、设计、职能类网申地址： http://hturl.cc/ogw3y 11.【中国港湾】招聘岗位：土木结构、财务金融、综合管理、语言类网申地址：http://hturl.cc/b6m0q 12.【中建八局一公司】招聘岗位：企业管理、设计、土木工程、基础设施、机电安装、金融经济、职能管理类网申地址：http://hturl.cc/p2vkf 13.【杭州衡泰软件】—筑梦Fintech无畏同行 招聘岗位：开发类、测试类、项目实施类、需求分析类、金融研究类 网申投递：https://xquant.zhiye.com/Campus 14.移卡 15.重庆移动（9.25） 校招字节跳动 哔哩哔哩 网易云 腾讯 阿里 蚂蚁金服 蘑菇街 猪八戒]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开发工程师——徐小平.md]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%BE%90%E5%B0%8F%E5%B9%B3%2F</url>
    <content type="text"><![CDATA[个人简历：徐小平——前端开发工程师 前端开发工程师——徐小平 个人简介重庆理工大学 | 信息管理与信息系统 | 本科 | 21岁 | 2020届应届生phone：18883616006 | E-mail：2533566560@qq.comWechat：freedown_end | QQ：2533566560Github：https://github.com/LemonSea个人博客：https://lemonsea.github.io/ 教育经历重庆理工大学 | 信息管理与信息系统 | 本科 | 计算机科学与工程学院 主修课程：C#程序设计、Java程序设计、Web程序设计、数据结构、数据库原理、信息管理与信息系统 荣誉/奖项：2018-2019综合丙等奖学金、2019-2020综合丙等奖学金 专业技能 前端基础：JavaScript / HTML / CSS（均熟练） 前端框架：React 技术栈（熟练）、Vue 技术栈、微信小程序、Bootstrap 后端基础：C#（熟练）、Java 数据库：SQL Server（熟练）、MySql（了解）、Oracle（了解） 版本管理：Git、SVN 项目经历仿网易云音乐WebApp项目描述：仿照网易云音乐制作的一款 WebApp，单页面 web 应用程序，包含播放器内核，真正可使用的 webApp 项目开发人员 主要技术栈：react Hooks + redux + immutable + rem 使用 react Hooks 进行开发 使用 immutable 搭配 redux 进行数据管理 通过图片懒加载、React.memo()等方法进行优化 使用 axios 完成数据请求 使用 媒体查询 + rem 实现响应式布局 使用 Git 进行版本控制 仿网易蜗牛读书微信小程序项目描述：仿照网易蜗牛读书制作的一个微信小程序，练手的项目…… 项目负责人 原生微信小程序开发 LeanCLoud 数据库 高考锦鲤小游戏项目描述：为某公众号迎合2019年高考吸引流量开发的一个小游戏 开发人员 .net 后端，jQuery 前端 使用 jQuery 的 Ajax 完成前后端数据交互 合作完成前端页面开发 独立完成后端业务开发 使用 SQL server 数据库进行数据存储 使用 SVN 进行版本控制 投稿系统项目描述：某公司外包项目， 开发人员 .net 后端，jQuery + bootstrap 前端 个人简介 熟练掌握 HTML、CSS 的基础知识，有一定使用经验，关注结构的合理性和语义化，能处理常见主流浏览器的兼容性问题，有基于 rem、vw/vh 的移动端适配经验。 熟练 react，有 react 项目经历。了解 vue，如果公司是使用 vue，也能很快上手。 对技术和业务都有旺盛的好奇心，持续关注前沿技术，持续更新自己，目前正在制作一个仿网易云音乐WebApp用以提升自己的技术能力。 平时有总结的习惯，每天坚持写学习笔记。 个性开朗，爱好广泛，善于合作，有团队开发经验。]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>个人简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-githubPage搭建个人博客.md]]></title>
    <url>%2F2019%2F09%2F07%2FHexo%2BgithubPage%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这篇随笔记录了我搭建这个博客网站的过程。大家可以跟着一起做一个博客出来。：） 一、安装 node.js 和 gitnode 下载地址：http://nodejs.cn/download/ Git 下载地址：https://git-scm.com/downloads （安装方法自行百度吧） 二、安装、配置 HexoHexo 官网：https://hexo.io/zh-cn/ 安装 Hexo 使用 npm 安装 Hexo，在 cmd 中输入： 1$ npm install hexo-cli -g 使用 创建一个 Blog 文件夹，然后在文件夹鼠标右键 Git Bash Here。在打开的命令行工具中输入： 1$ hexo init folder 其中 folder 是创建的 hexo 的文件夹的名称，可以为空，如果为空的话，会默认以当前文件夹初始化。 进入新创建的文件夹： 1$ cd folder 安装依赖文件： 1$ npm install 之后生成静态文件： 1$ hexo g 现在就可以看见效果了，启动服务; 1$ hexo s 默认会以 4000 端口启动服务，如果想用其他端口，可以用下面代码： 1$ hexo -p 5000 server 上面的代码就是以 5000 端口启动的服务，可以在浏览器中输入端口号看到我们的初始博客：http://localhost:4000/ 三、设置 hexo 主题 现在的主题有点丑，我们可以换一个好看的主题，我用的是 Next 的主题，所以这里以 Next 的主题设置方式来举例： Next 主题官网：http://theme-next.iissnan.com/ 下载 Next 主题 使用如下命令把主题下载到我们的 hexo 中： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完成后我们可以在 根目录的 themes 文件夹下看到 next 文件夹，这个文件夹里面就是我们下载的主题。 更换主题 在根目录下有一个 _config.yml 文件，我们先把它称作 站点配置文件； 在 next 文件夹下也有一个 _config.yml 文件，我们把它称作 主题配置文件; 我们在 站点配置文件 中，找到 theme 字段，这个字段就是用来指定主题的，我们把它的值改为 next，这样我们就已经换好主题了。 四、站点配置 更换博客默认语言 在 站点配置文件 中，找到 language 属性，把它的属性值改为 zh-Hans，这样，我们的语言就已经设置成中文了。 设置站点信息 在 站点配置文件 中找到 Site 模块： 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 根据需要自己写就行了。 设置头像 将你的头像放入项目根目录中的 public 文件夹下的 images 文件夹下，然后在 主题配置文件 中找到 avatar，将 url 设置成 /images/你图片的名称.格式。这样头像就设置好了。 更换 favicon.ico 将你选择的 favicon.ico 图片也放入这个文件夹下，然后把 主题配置文件 中的 favicon 属性的 small 和 medium 改为你放入的图片的路径。 五、启用菜单在 主题配置文件 中，找到 Menu Settings 属性，它就是启用各项菜单项的： 启用分类菜单 在 主题配置文件 中，找到 Menu Settings，将其属性 menu 里的 categories 启用。 然后在 Git Bash 命令中新建一个分类页面： 1$ hexo new page categories 可以看见 source 文件夹下面有了 categories/index.md，在 index.md 中加入： 1type: "categories" 同时将 title 改为中文： 在写文章的时候，只要在顶部的标题下方添加 categoried 字段，就会自动创建分类名并放入对应的分类中： 启用标签模块 方法与上面相同，在 主题配置文件 中，找到 Menu Settings，将其属性 menu 里的 tags 启用。 然后在 Git Bash 命令中新建一个标签页面： 1$ hexo new page tags 可以看见 source 文件夹下面有了 tags/index.md，在 index.md 中加入： 1type: "tags" 同时将 title 改为中文： 在写文章的时候，只要在顶部的标题下方添加 tags 字段，就会自动创建标签名并放入对应的标签中： 需要注意的是，一篇文章的标签可以对应多个，但分类只能对应一个。 启用关于模块 同样的，新建一个关于页面： 1$ hexo new page about source 文件夹下有了 about/index.md，在 index.md 中可以随意编辑。 六、添加插件功能 添加搜索功能 安装插件：hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 在 站点配置文件 中找到 Extensions，并添加： 123456# 搜索 search: path: search.xml field: post format: html limit: 10000 在 主题配置文件 中找到 Local search，将 enable 设置为 true： 添加 RSS 安装插件：hexo-generator-feed 1$ npm install hexo-generator-feed --save 在 站点配置文件 中找到 Extensions，并添加： 123456789# RSS订阅 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 在 主题配置文件 中找到 rss，将 rss 设置为 /atom.xml： 七、同步到 Github 在 Github 上新建一个仓库： 这里因为我已经创建了一个了，所以按钮是不可选。 配置 SSH key 如果你没有配置过，在 git bash 中输入如下命令： 1$ ssh-keygen -t rsa -C "邮件地址" 连续三次回车，它会告诉你一个文件目录，去目录里面找到 .ssh\id_rsa.pub 文件，用记事本打开并复制里面的内容，填入： 在 git bash 中输入下面的命令测试是否成功： 1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示 Are you sure you want to continue connecting (yes/no)，输入 yes，然后会看到： 1Hi liuxianan! You've successfully authenticated, but GitHub does not provide shell access. 这个信息说明 SSH 配置成功了。 最后的配置，命令行中输入： 12$ git config --global user.name "liuxianan"// 你的github用户名，非昵称$ git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱 同步到 Github 在 站点配置文件 中找到 deploy，并修改： 要部署到 Github，我们需要安装一个插件： 1$ npm install hexo-deployer-git --save 然后在 git bash 中使用下面的代码进行部署： 1$ hexo clean 1$ hexo g 1$ hexo d 完结至此，博客就搭建好了，你也可以来尝试写自己的博客了。：）]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
